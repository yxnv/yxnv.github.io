<!DOCTYPE html>
<!-- @yxnvCraft version Alpha 0.6.1


    Controls:

 * Right-click (or ctrl + left click) - place block
 * Left-click - Remove block
 * Middle-click - Pick block
 * Q - Sprint
 * Shift - Sneak
 * W - Walk forward
 * S - Walk backward
 * A - Walk left
 * D - Walk right
 * E - Open inventory
 * B - Toggle super Breaker
 * Z - Zoom
 * L - Toggle Spectator mode
 * Enter - Toggle slab mode
 * Arrow Keys - look around
 * P or Esc - pause/unpause
 * 1-9 navigate hotbar
 * Spacebar - jump
 * Double jump - toggle flight
 * Shift (flying) - fly down
 * Space (flying) - fly up
 * Delete - Forced restart (wipes the world and changes seeds)
 * T - Reload textures
 * ; (semicolon) - Release the pointer without pausing (for screenshots)

-->

<html>
    <head>
      <link rel="icon" href="/your_path_to_image/favicon.jpg">
        <meta charset="utf-8">
        <title>yxnvCraft</title>
    </head>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            overflow: hidden; /* Hide scrollbars */
        }
    </style>
    <body>
    <canvas id="overlay" tabindex="0" width="600" height="600" style="position: absolute; top: 0px; left: 0px"></canvas>
    <textarea id="savebox" hidden="true" spellcheck="false" style="position: absolute; top: 10px; left: 10px; z-index: 1;"></textarea>
    <p id="savedirections" hidden="true" style="position: absolute; top: 40px; left: 10px; z-index: 1; background-color: rgba(255, 255, 255, 0.3);">
        To save your world, copy/paste the saveString<br>
        from this box into the code on line 73.<br>
        var loadString = "Your Code Here";<br>
        Then save the program as a Spin-off.
    </p>
    <p id="message" hidden="true" style="position: absolute; top: 10px; right: 10px; z-index: 1; text-align: right; background-color: rgba(255, 255, 255, 0.3);"></p>
    <script>
        var superflat = false;
        // Code edits will erase the world.
        // Place save code here to load your world. Make extra sure you got it copied so you don't paste in the wrong thing and delete your world on accident lol
        var loadString = "3rmitl;g,1v,-a,-a,6b;2;0,4,-2,0,4,-1;begy,beo2,bhni,bhum,bkta,bkzs,bnz2,bo5k,br4u,brby,buaq,buhu,ct1e,cw7y,czd4,d2iw,d5pa,d8v6,d92a,dc4i,dcbm,e7lu,ease,edxk,eh3c,ek9q,enfm,enmq,eqle,eqsi,fm6a,fpcu,fsi0,fvns,fyu6,g202,g276,g59e,g5gi,h0qq,h0xu,h3xa,h44e,h732,h79k,ha8u,hafc,hdem,hdlq,hgki,hgrm;bbpe,bbwi,bc3m,bevy,bf32,bfa6,bi14,bi88,bify,bl6w,ble0,bllq,boda,boke,bori,brj6,brqa,brxe,cqo2,ctum,cx0e,d066,d3by,d63m,d6aq,d6hu,d9cy,d9k2,d9r6,eeqm,ehwe,eko2,ekv6,el2a,entu,eo0y,eo82,fjsy,fmzi,fq5a,ftb2,fwgu,fz8i,fzfm,fzmq,g2hu,g2oy,g2w2,gxz6,gy6a,gyde,h15q,h1cu,h1jy,h4aw,h4i0,h4pq,h7go,h7ns,h7vi,han2,hau6,hb1a,hdsy,he02,he76";
    </script>
    <script type="application/javascript">
var canvas = document.getElementById("overlay");
var ctx = canvas.getContext("2d");
var savebox = document.getElementById("savebox");
var saveDirections = document.getElementById("savedirections");
var message = document.getElementById("message");
ctx.canvas.width  = window.innerWidth;
ctx.canvas.height = window.innerHeight;

/* Set this text editor to max width by copying this into the JS console:
document.getElementsByClassName("_1chbfei")[0].setAttribute('style', 'max-width: 100vw !important');
*/

var MathGlob = Math;

function GirlCraft() {
    let Math = MathGlob;
    let setPixel, getPixels;
    let textures = {
        grassTop: function(n) {
            let r = 0, g = 0, b = 0, d = 0;
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    d = Math.random() * 0.25 + 0.65;
                    r = 0xff * d;
                    g = 0xa0 * d;
                    b = 0xff * d;
                    setPixel(n, x, y, r, g, b);
                }
            }
        },
        grassSide: function(n) {
            let r = 0, g = 0, b = 0, d = 0;
            let pix = getPixels("0g0g01017eb3lr17eb4e717egpvj17egqnz18i9gcf18i9h4v18if2m718if3en18if47318ikr9b19m7tvj19m7unz19mdg5b19mdgxr19mdhq719mj3zz19mj4sf19morun1aqhhj31aqhibj1aqn4lb1aqn5dr1aqn6671aqssfz1buli4f1buliwv1bur56n1bur5z31cypji71cyv5rz1cyv6kf1cz0su71e2tk3j1e2z6db1e2z75r1f736yn494qbicd6lvit7l44qdj03ecg39lj737ai0d43fiuikxqdsciuiuo873339ddsditscdktcqdqspdtmsdc4if9cccdyd2lhyluiwfqksd896d3ufhn8d8ldddtycp6hl010444ak59n7dcli494qbicd6lvit7l44qdj03ecg39lj737ai0d43fiuikxqdsciuiuo873339ddsditscdktcqdqspdtmsdc4if9cccckgcihyckiwfqkssturizoq");
            for (let i = 0; i < pix.length; i += 4) {
                setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i+1], pix[i+2], pix[i+3]);
            }
            for (let x = 0; x < 16; x++) {
                let m = Math.random() * 4 + 1;
                for (let y = 0; y < m; y++) {
                    d = Math.random() * 0.25 + 0.65;
                    r = 0xff * d;
                    g = 0xa0 * d;
                    b = 0xff * d;
                    setPixel(n, x, y, r, g, b);
                }
            }
        },
        leaves: function(n) {
            let r = 0, g = 0, b = 0, a = 0;
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    d = Math.random() * 0.25 + 0.65;
                    r = 255;
                    g = 50;
                    b = 255;
                    if (Math.random() < 0.35) {
                        a = 0;
                    } else {
                        a = 255;
                    }
                    setPixel(n, x, y, r*d, g*d, b*d, a);
                }
            }
        },
        hitbox: function(n) {
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    setPixel(n, x, y, 0, 0, 0, 255);
                }
            }
        },
        acaciaLog: "0g0gm157nqin16brqbj16brr3z16bxddr17fvqwv17fvrpb17g1d6n17g1dz318jzri718jzsan18k5drz18k5ekf19o3s3j19o3svz19o9edb19o9f5r1as7sov1as7thb1asdfr31bwbta71bwbu2n1bwhgcf0b2fllff7j6jk1ke7a2dg1ffagbililfjb4c31gg7cfglllgi75g61hg7fgf9lljgicga3hf5gif3b5jfbcjb71f8fif2a1kgg61f32g9dki1f1lig31i3cicdll1j2lji31kchj7g8idkclgkb1l2gi7f8fllliclk7l1f4bg9clll18llgl4g2gifdlll4ilkilci4kcigldjlhfkflgjfk2fkl2fl278gllilg1fkl2f70a4jllel72gkl2i3",
acaciaLogTop: "0g0g01r18jzri718k5ekf19nha7z19nmwhr19o3svz19o9edb19o9f5r1arfojj1arwjcv1as7thb1asdfr31bvjocf1bvpben1bvuxof1bw0kqn1bwbta71bwhgcf1d0a7lr1d0ftvj1d0funz1d0lgxr1e42yv31e42znj1e4e8731e4jugv1e4jv9b1f8clq71f8i8sf1gbiv3z1gcb01r1hfh9fj1hfmvpb1ijla0v1ijqwan1jnuwvz1krtb7j1lvrpj31lvxbsv1n01ce71o37kzj1o37lrz1o3d79b1o3d81r1o3zqpr1o4az9b1p7blkv1p7h7un1p7h8n31p7muwv1p89dkv1qbfm671qbl8fz1qbqvi71qbwhrz1qbwikf1rfuw3j1rg0idb1rg0j5r1rg65fj1rgbrpb1rgbshr1ska60v1skfsanoo6kgortmnfoooooooao71d1p1p1m1l10bkaao1aoy1m1c1f1e1e1f1f1mwiogoay1k1f1n1n1n1m1n1o1a1mxoooc1l1c1p1m191516161k1n1f1kco51d1f1p1m1a1o1p1p1m1a1k1o1fzgn1p1e1p1a1m1o1a1a1p1m161n1f1jie1n1f1m1a1p1a1k1i161m151l191ihl1n1f1n1a1p1a1g1g161m191k141i841m1f1p1b1m1i1a1a1n1p161h131i9k171f1q1m1a1o1m1q1p161m1o1611ko21n1f1o1k1a1a1a1a1m1m141mdoaku1l1f1p1p1m1m1m1k131is1oooiv1l1f19141313161ovfgo6ifo2181m1k1m1l123g19jjooooopnqpaoo0kk",
acaciaPlanks: "0g0gj1p6p24f1p6p2wv1p6up6n1qat2pr1qat3i71qayprz1rex3b31rex43j1rf2pkv1rf2qdb1sj13wf1sj6q671sj6qyn1sjcd8f1tnaqrj1tnarjz1tngdtr1urercv1ures5bggfec5cfiigfd9fgfccc92ccffdc93cc969693bbac9963862233303333333233ffc3cfhffdb3cgffec93cccdcb53cfed9595cb99545298562333320222213313fgfffc2cfffff93ccffec63cffffc93eca99534aa996532c3333033322220223fffc3cgfgffc4dffffdb3cdeecc93dffc9863acb995627663335153201101332",
andesite: "0g0g60sywflr0wb8hdr0yjgikf11vsl4v17gcnb31asolxb2114332104423221245323445330122411334410122443224410133445433231235442223333211433323243210013432324542104543333423310154332333433114143343224533143342221154333332321101544332201331254422332333443443233212331543333334533112233301244323223541321322323234432",
bedrock: "0g0g508ww4xr0ddc7b30neccn30qqoef31584m4f3111124324211212133434341443012110110111412224232433202422111112014111121134433112221221102211014432344323443410222122211011213234421122344344442110121213211143334134410144431102221123442334402111321134111112343420211101234433211211234421121011044312301123",
birchLog: "0g0g01w06oo3r307smha707ss4cf0a105j30c986pr0ddc7b30ehaku70flk8hr0gpimtb0htmmm70ixqn7j0l5t24f0ma2ozj0ne13b30ne6qdb0qqd5330ruh5of0syl69r0u2p6v30warlrz0yj598f0zn3mrj0zn99tr12zfpbz143jp4v157nqin16brqbj18jzri71bw670f1d0a6tb1e4e8731f8i8sf1gcm8lb1hgkmwv1hgq96n1iku9rz1joso3j1kt2ayn1lwv30f1lx0pa71lx6bjz1lx6ccf1n1ac5b1o58qgv1o58r9b1o5edj31p9cr271p9ie4f1qd5ibj1qdgrnj1qdmepr1rgsmin1rgy9kv1rh3vun1rh3wn31rh9iwv1rhf56n1rhf5z31rhks8v1rhqein1rhqfb31sl7wfz1sl7x8f1sldji71slj5rz1slj6kf1slosu71slotmn1f1m1ai72c1u1h1u1c1u1q1l1v1o1j1m1l1o11jy1u1h1u1j1u1u1u1v1o1t1m1m1o1e1g1s1u1j1t1s17zqr1u1u1m1m1u1e1g1r1u1k1uo223n1u1u1u1t1u1m1i1s1t1m1u451161h1u1u1n1o1u1o1m1g1s1m1u13t121n1g1u1u18eg141e1h1s1m1u1v1u1g1s1g1u1uv027k1r1tm1a1v1v1h1u1g1u1n601031u1ud131m1u1s1v1p1u1uq1ilx1u1u1m1u1m1u1v1v1t1u1t19101m1v1l1u1h1m1u1s10p1v1u1l1m1v1v1u1v1m1u1g1t1u1ubh1v1v1m21a1v1u1v1t1u1i1t1t1u171u1s1u82u1v1u1v1u1u1r1t1h1u1v1v1g1u2aw1m1brs1d1u1s1g1u1v1v1g1u151l1n1m902f1v1m1h1u1v1v1h1u1e",
birchLogTop: "0g0g01k1qd5edb1qd5fy71qdb27z1qdb30f1rgy39b1rh3pj31rh3wn31rh9bsv1rh9clb1rh9eyn1rh9fr31rh9iwv1rhf3lr1rhf4e71rhf5z31rhkoan1rhks8v1sl23un1sl7q4f1sl7qwv1sldd6n1slderj1sldji71slj08v1slj11b1slj1tr1slj2m71slj4zj1slj5rz1slj6kf1slor9b1slos1r1slosu71slotmn1tpbx1b1tphdrz1tphekf1tphfcv1tphjb31tphk3j1tpn01r1tpn0u71tpn1mn1tpn2f31tpn37j1tpn6db1tpn75r1tpsnwf1tpsoov1tpsrun1tpstfj1utlfy71utr27z1utr30f1utwohr1utwpa7y1at1ex1e1ducvm1ay1e1e1e131eww2171g1g1615l1tww1eewsf16ijiijj159s1ax1etf15j161b1b1b1b1c8169191e1e315i1g155555151bk1031ag17i1g1b8171g1g168101cjlwr1fi1g8151c881g16516j10sc16i16i1g815z5155155ord16i1bi1g8kn51b5104odd16k1ii1bz88161g7144ls19pk1j1681c161h1g5161c5p191911bk1c10iiii1516416c19w13016j1g1g1b151b154109e1a1e1es915kh44451catw1ew1ew1931811101616q3tbw1e1e1e1e1e1a1919rr12w1e1e61e1e",
birchPlanks: "0g0gl1rh9bsv1rhey2n1rheyv31sldce71sldd6n1slizgf1slj08v1slomin1slonb31tpn01r1tpn0u71tpn1mn1tpsnwf1tpsoov1utr27z1utwohr1utwpa71utwq2n1uu2ccf1vy0pvj1vy0qnziifec1cgkkifd4fifccaa2achgdc91cc7679a5a76a66a5aa1223303455233145jhf5fgkhgdc5gkiheca5cccdcc95ghed77a5ca665563ca692343440555525525fjhhgc3chggggb3dcggea65cfgggca4fa655552aa87aa53c2222031233331335jggc5cjhjigc4dghhgdc4cdffcaa4efgaaaa2aaa9a793a9a1223054412100451",
blackConcrete: "0g0g40149on3028826702882yn028dp8f1330112022012232303130022112212111032203010022012122012222321221011223213030101033110011212233120230013131003200032022012002002112233122202312230200102211312102222122132011021201223320211021220121122122321331201102120210001220112022023302312210123220102110",
blackWool: "0g0gf0149on3028826702882yn028dp8f03cc2rj03cc3jz03chptr04gg3cv04glqf305kk3y705kpr0f06oo4jj07ss54v08ww5q70a106bj46348b45ab13993299eebb7742570367bc77dc97bcbbdeb996bc768c47cc96ec9749bb115953bb31314c414641672547eebb8879bea7eeb966eebacc45bca9ccbb35ca4657528733577b117949ee7beeccbbecbacb799839349966bb445911796611cd318b9bee92badecb9717bc77cedc97c99beb559b6424c946cd76ac44bc",
blueConcrete: "0g0g30c98pof0c98qgv0c9ecqn1000001101000201011001000101120101211111010200000001000110100100220110011001121111001100100100010200102101101000000011110001101010101011020111110000000101121111101100100100010110111010210111001101000100000111110100101111000120000010100000110001200110010002",
blueWool: "0g0gj0c98pof0c98qgv0c9ecqn0c9edj30ddcr270ddidbz0ddie4f0ehgrnj0ehgsfz0ehmepr0ehmfi70flkt1b0flqfb30flqg3j0flw2db0flw35r0gpugov0gq02yn0gqbd3335237c44ac12992289iidc6632460256de67ge96cebbhic985ce657e46ee85ie9648cc114942cc21214e413541562436iidc7769dia6iic955iicaee34cea9eecb24ea4546427622466d116949ii7biieecciecaed699728249955cb344911695511eg217c9bii92bahiec9617be67eigf86e99cid449b5324e935eh65ae34de",
bookshelf: "0g0gt03fxnnj04laqdb0a0ot1b0b6j6db0c8r6db0deww730df88ov0egz6rj0gpo9330ht5kov0k20av30nf40zj0pnc1dr0qoh8fz0sy416n0w8kcn30wc5n9b0yicu0v11vb08v11vskcf13z03jz16atkvz17fehvj1as1ce71czhmv31e50qv31g6nvgf1gbtpfj1ks44qnommllhlllmmmmlmoo44477444772534oo799kk999ni9637olkffqk99gpjk631lsqffqk64gnik631soqfdqf6gcngf651ookd9kf3c7igf350mlorrsssroorrroolollmmhmllmmmllhoo77227cb7427724ooqk763gck99cb97olpj063gckq4gc10hsqk063a8fqkgcpjsoqf065a87kqgc10omkfe35ccefkcb03oorrsssroorrrrooo",
bricks: "0g0g90v532m70yh9gjj11up1bz12xjv27169kmpr18jd4vz1arwg731cxrt331ihuy2n7742888777458777443513444435144410060033100503112256522225565222887747458777474214444315133333151341110600133105522225565522225677458887474588774435344444153444110511331106133325565222225652224777474287774745144444353444441501111106011111065222225655222566",
brownConcrete: "0g0g30pl5gqn0qp3u9r0qp9hbz0211211202222221222122211211122121011102222222212211200222112101121111211111222121222122122221201212121222112122222221220222222122221201121212022122122110221211122221211011221212121010121011111212122221121221222212122112112112211010222111121211220222221122",
brownWool: "0g0gi0qp3u9r0qp9hbz0rt7uv30rtdh4v0sxbunz0sxbvgf0u1a8zj0u1fv9b0v5e8sf0v5e9kv0v5jvun0w9i9dr0xdgmwv0xdm9z30yhkni70yhq9rz0zloo3j0zluadb35228d45bd12aa219bhhed7721570257ef77gfa7dfccghdb95df758f47ff95hfb749dd115a52dd21214f413541571526hhed887aehb7hhda55hhdbff25dfbbffdc25fb4557518722576e117b4bhh7chhffddhfdbfe7ab82924bb55dc245b116b5511fg218dachhb1cbghfda717cf77fhgg97fabdhe55ac5214fa25fg75bf24ef",
chiseledQuartzBlock: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov0444404333022440043331222204444003322111000444300222223004443331023011101110022103315544432202200110441100220000554444144033344544433204314444440111230011441101054044444432154104400110111004401444454005544440133321100004443002323155440333300444414444132220",
chiseledQuartzBlockTop: "0g0g51p9z6kf1qe37y71tq9ngf1tqfbb31uujcov0334314232133420021100022000112002044203204421200204120420412021020113032020003102233304212233200000000421110000323433442223344422222222222222220000001321000001044343142143222104011204214110201302130420313020120234032023403002111003201100400222314222133420",
chiseledStoneBricks: "0g0g70oigd8f0qqoef30sz21vj0xf6vpb0yjgikf11vskcf17g711b6666655666566562644424444224444054110000111123205206665566561530640654434442154064064322334315405205430005421630540632000643062052054300053206306215435655420630641644545432053064163232322215406421110000011530556655666655543053343234433232202000000000000000",
coalBlock: "0g0g501440sf03cc1z305kk35r07ss4cf0b5464f3322122002210012222121000210123321000122000022221001243222202210001233222100210020222221000001220132211001122222022210122343221002110123322210000012123221103200212122210002211232102112210012230002113432123322000123420023221000123210012221001222212212221000",
coalOre: "0g0g01e0b5464f0c986pr0ddc7b30ehaku70ehg7wf0flk8hr0gpo9330htmmm70hts8vz0ixqn7j0ixwa9r0k1unsv0l5yoe70ma2ozj0ma8c1r0oiaq670oigd8f0pmeqrj0qqd4an0qqircv0ruh4vz0rumry70syl5hb0u2p62n0v6t6nz0wax6gv0wax79b0xevksf0xf17un0yizldr0yj57nj0yj58fz0zn3lz30zn988v0zn991b0znkj5r10r7mkf10rd8u710rd9mn10rojr311vbn5r11vh9fj11vha7z12zfnr312zla0v12zlatb16c8mpr1bwspof1d0wq9r1ilgt8f1918181818181716151410os1416161717vs121817171714v001141510k000cp1515n41d40s12t0g1b001w12y1de00s10q21c6002qwb0000614s060001tw21001t15u100001y11m111i151515911lnvwrttos1414141812w1212f051hww101112141414141110d01306w10111010111010yvoi3000110xwwwvvvd00z1000wobkvyww511a0000101090a1014141210b22101617q1307141515141514141415161717n00815171616161616161716141411kbj16",
cobblestone: "0g0g60ma8c1r0qqoef30u30g7311vmy2n19okohr1e50qv32144011454313543145330554330132314342143342101321132113232134310021354131154443152453321033543234313433211243215332233213541231321542213533311021543232233121341323231101221044532211235411035532354215434213323154331432332113244323212332143111311232121135432",
cyanConcrete: "0g0g305objsv05obklb05oh6v31112010122111202100121222111122012212211101111202102221210222122211111211221111011021102021212212220211021022022201210110010212210211110202101010201110112020221222112102111202212110222110211221001010211001221212202222122111221102211100222112011211120220211",
cyanWool: "0g0ge05obklb05oh6v305omt4v05omtxb05osg7305oy2gv05p3pj305p9bsv05p9clb05peyv305pkl4v05pklxb05pq87305pq8zj242269347912662167dda95521450145ab55cb659b88cd97649b546b35bb64db7536991146419921113b312431451424dda96656ad75dd9644dd97bb249b77bb9814b73445416521454a115737dd58ddbb99db97ba56762623774498234711474411bc116968dd7187cdb965158b55bdcc65b679da44684213b624bc547b23ab",
darkOakLog: "0g0gk0swec5b0swjyf30swjz7j0swplhb0u0iby70u0icqn0u0nz0f0u0nzsv0v4mcjj0v4mdbz0v4me4f0v4rzlr0v4s0e70w8qd4v0w8qdxb0w8qepr0w8w0730w8w0zj0xcorgf0xcuein0309eb9jbgeee0b91216d09b2biee9ebe716b4eb16ebbdjeg91660ac18e65beeee9c61bb5be9581beecb78069eg7560bee706e169ej7060bee608b679ejb0b0egf60c9999e9e6e9gej30b1699e6igje9ejc4b061be9ijjb09jg6b1619e9ehec19eg8b671b67ee69e79g6b696b06ge19j1696bb7b906ge199069bbb6b619je199",
darkOakLogTop: "0g0gy0u0iby70u0icqn0u0nz0f0u0nzsv0u0tm2n0v4mdbz0v4rzlr0v4s0e70v4xmnz0w8qd4v0w8qdxb0w8w0730w8w0zj0w91n9b0xcuein0xd00sf0xd5nun0ygyf3z0yh9ofz0zl2ewv0zl81z30zldo8v10pc1rz10pc2kf10phou710phpmn11tg35r11tlpfj11tlq7z12xk3r312xpq0v12xpqtb141o4cf141tqm7772ab7cjffheb7ab773a9qvrqqk6b46e677itnnmmnnqf6fbfbisnsvvvvvlqfbefbultskikirtnp6aarntuluwvulttnl6fvnvlutlluulvns6bumulvlrsluiuksaevmulwlsrkvktir67vnwluqlltvkriq3fpnwtltuxvltukk6e7unvrllllstiqb73bgsnvvvuvriod1b7bbgsnkiiiisg46f2ab64puttsn6a05e6bfab788eb6fb17e",
darkOakPlanks: "0g0go0zloydb0zloz5r10pncov10pndhb10psyyn10pszr311tlr0f11trda711tre2n11twzjz11tx0cf12xprlr12xvdvj12xvenz141o54v141tren141ts73155s5q7155xrzz155xssf169w6bj169w73z16a1slb16a1tdrjjjig2gjnnnjh6jjjgggg1dgkjhgb2ggbbb8a498bcbbc2aa1111102222122123mki2ijnkjgg6jnkkigg5ggghggb2jkihbbf6gfbbbbb1cgbb2222220222327515iljkjc1gjjjjjg2ggjjif72gjjjjgc2jeb77551bbbbbb41c6111011236211113ljjg2gnknkjg2gjkkjhg2ghiiggg2gjjbbca1fgfbgbb1cbb2111066322222222",
diamondBlock: "0g0g903j2mf305ranlr0gw3jen0k8fitb0s0fda70vcg7b317k3wu71n3h8n31y711j33333223332222331378866777664477138445766432235713845766543335561265666543345546126666543346643203766555446643220376555445543323026555445544333412655445544443541245446644444653023446643343664302346643223554341225543223444335123233223443345601101100011001100",
diamondOre: "0g0gk093bif30a87ny70cft81r0cga2v30prw7i70yj58fz0zn3lz30zn988v0zn991b0zryigv10r7mkf10rd8u710rd9mn11vbn5r11vh9fj11vha7z12zfnr312zla0v12zlatb1rjascfihhhhhgfeddegfffgghhhhgggggg93eeaabcdddeefggfecc66639j9999993dcaba39jjj9999943ddg1139j999994311egg214444444112eeggd2211222220dddhedd02112000abcddddba021120abaabaa87760220aa766655555660088jj55586j1288bcdc2208addc2cccdefgf0eddeededddefggggeeegffffffgfdddddef",
diorite: "0g0g60xfchz311vskcf19of1fj1gd8su71ktouf31smgykf1222352233524355201322135345543151355101325543235255312553213225351243153532255245355541332335235332455214554102243123234555521232203255443244250155213551234541244310134335513055510144221512352542543554223223212343125454353242115521455321245235554124421255",
dirt: "0g0g01017eb3lr17eb4e717egpvj17egqnz18i9gcf18i9h4v18if2m718if3en18if47318ikr9b19m7tvj19m7unz19mdg5b19mdgxr19mdhq719mj3zz19mj4sf19morun1aqhhj31aqhibj1aqn4lb1aqn5dr1aqn6671aqssfz1buli4f1buliwv1bur56n1bur5z31cypji71cyv5rz1cyv6kf1cz0su71e2tk3j1e2z6db1e2z75r1f736yn494qbicd6lvit7l44qdj03ecg39lj737ai0d43fiuikxqdsciuiuo873339ddsditscdktcqdqspdtmsdc4if9cccdyd2lhyluiwfqksd896d3ufhn8d8ldddtycp6hl010444ak59n7dcli494qbicd6lvit7l44qdj03ecg39lj737ai0d43fiuikxqdsciuiuo873339ddsditscdktcqdqspdtmsdc4if9cccckgcihyckiwfqkssturizoq",
emeraldBlock: "0g0g605rfklb05sdfr306ug5bz07xmd4v0i0nv270zs3pq70000000000000002055555454551144305000000200002430404555411114243050500000002425305050555445212130405054411421203040405451142120305040411020202130404041122120213042105410112420301212222222242030405510000441213012222222222224301011001110014532333333333333332",
emeraldOre: "0g0gg07y8sn30baqgov0mfp0cf0yj58fz0zn3lz30zn988v0zn991b10r7mkf10rd8u710rd9mn11vbn5r11vh9fj11vha7z12zfnr312zla0v12zlatbfeeeeedcbaabdcccdde1eeddddddc21b77120aabbcd1cb09441204721a120a9787504451aa120aaadcbaaaabbaa0aaabddbaa8888889aabbd2aa186214719aaae0a120600412089aaaa120677712077877650467777054443333344676643333642446621a976217aa11099a0c21c10ab000aaabcd10db0bdccccccdcaaaaabc",
glass: "0g0g800000001tojoxr1uscg731vwm3un1vwxd6n1y4zrb31y5b1fj1y711j36666666665555555600000000000000560777700000000056077000000000005607000000000000550000000000000055000000000000004500000000000000450000000000000045000000000000003500000000000000350000000000000024000000000000002300000000000000230000000000000023112222222222222",
glowstone: "0g0g80u1fugv0v5phbz10pn01r11uj6db1kqv1tr1x1ncov1y6jzlr1y711j35420045440276423654011240346654024032201131054033034542017510033014766405664136502566552454236751004554020132450531024010352320465230213276501576442654346640335420454220452013000320356304012311354016754036520357660354215764034654201003242013154216521100013",
goldBlock: "0g0g91kr60vz1lvfpbz1vx7ojj1x0jk731y5lf5r1y5wq2n1y6dlof1y70g731y70ovz2222332223333221278866777664477128445766423325712845766542225561365666542245546136666542246642302766555446642330276555445542232036555445544222413655445544442541345446644444652032446642242664203246642332554241335542332444225132322332442245601101100011001100",
goldOre: "0g0g0290yj58fz0zn3lz30zn988v0zn991b10r7lrz10r7mkf10rd8u710rd9mn11vbn5r11vh9fj11vha7z12zfmyn12zfnr312zla0v12zlatb143e0hr143jnjz157nncv16bm0vz1gbo9hb1hfmn0f1ijqnlr1jnp0cf1krndvj1n0ywhr1o3ze2n1o452pr1o4gc1r1p7xrlr1qc1ren1qc1s731qc7f9b1qciolb1qciq671rfuinz1rg05q71rh9b0f1sk46bj1sk9tdr1skffnj1todt6n1todtz31touqdb1tour5r1ushtrz1ust3wf1utlbzz1uu296n1vwltkv1vwrgn31vwrhfj1vwri7z1vwx5a71vxuznj1vy0lxb1vyn6671x0vh8f1x0vi0v1x0vitb1x115331x1cf7j1x1npbz1x24min1y554vz1y555of1y5ary71y5atj31y5gf0f1y5m2v31y5rp4v1y5rpxb1y5xc731y5xczj1y6301r1y68mbj1y6e9dr1y6jx8f1y6pkan1y70vzz1y70wsf1y70ydbedddddca9889caaac2821161cdcco1b27261x1ng95813z1c88a9a1x1x1m1dv711111252624g89cmtp5652124271y1p1p1sr98888ca9881g171512r888889cg2424966666671w1w99c101h281j24311151w26221e8d91t1t1t1v1o2211w27241zw8888buul581w2324201rq6553b31352020201z1r1es1000281i11381f19y11z4031w1w1a1k1kx6787hi4358b718141d7892126211d988998bfb891m1l1q1u1d999caaaaaacabknj89a",
granite: "0g0ga0l56fi70plgu0v0yhw0sf1424tmn17eb8cf1aqna4f1e3al8f1e3x7un1jnje2n1qczoxr7434244344046445431548244224422341444335249241464143446145532344234232113754334244255342143347242445524442555322424474302155243346344255522344245535242552464245557314243844212555415442024425030323244424324439435524312355344448553215435547245544733324244425",
gravel: "0g0g80rubhtr0v6t6nz0znew3j11vh9fj157tbzz1584m4f1d0a60v1d0r37j0341152512122521522122312102333522103133522351352232321522512322132641122210253202140133527552213104227515530122553253522311225353521223310257122311752152322132123553102521325022533572113225212132222536415525331025232422215235323311243310351264122232321212",
grayConcrete: "0g0g20ehlvr30flk9a70000000000000000000000000000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000100000000000000000001000000010000",
grayWool: "0g0gd0ehlvr30flk9a70flpvjz0flpwcf0flvim70gptwxr0gpzjzz0htxxj30hu3jsv0hu3klb0iy1y4f0iy7ke70iy7l6n333359337803663157cca85531350135ab55cb658b88cc87539b545b35bb53ca7535990036329930103b303330350335cc995556ac75cc8633cc87ba339b77ba8813a73435305532355a005737cc58ccab88cb87ba56753533773498333700574300ac205968cc7087cca865058b55bccc55b679ca33684313a634bc537a33ab",
greenConcrete: "0g0g20k2mku70k2s73z0001000100111100101010100101101101101100111010010111001001011000100001100011000100101010110101111010000001011001001000100001010110101110010011010000101011110000010110101000000001010000110101011101000111110011101010011000111100001100011000000111101001101100",
greenWool: "0g0gh0k2mku70k2s6bj0k2s73z0l6qjun0l6w64f0l71rlr0mb054v0mb5qm70mb5ren0nf9qf30nffcov0ojdq7z0ojjbpb0ojoxz30pnnbi70pnsxrz0rw0y6746447c45ab1499419aggcb8841580168ce88ee98bebbfgba96ce867e48ee96gda849cc125953cc41114e424642681546ggcc7789cga8ggb966ggbaed45ceaaedbb15da4658517843586c21894agg8bggdebbgebaec89a749449966cb445a116a6621de327c9bgga1bafgdb9828be88egee98e9acgc559b6414d946ef86ad44ce",
ironBlock: "0g0gb1d0wq9r1f94rgf1hhcsn31lxn7y71n1wvlr1pa4wsf1qe8xdr1ricxz31smgykf1tqkz5r1uuozr332233333333222232aaaaa9998777772277777777777777105555555666444402aaaaaa999777771277777777777777105555566664444402aa9999977777771277777777777777105555555566644402aaaaaa999977771277777777777777105555556666444402aaaa9999777777127777777777777712222222112111111",
ironOre: "0g0g0240yj58fz0zn3lz30zn988v0zn991b10r7lrz10r7mkf10rd8u710rd9mn11vbn5r11vh9fj11vha7z12zfnr312zla0v12zlatb143e0hr16bgdtr16bgem717f94an18jd4vz19nbhmn19nbif319nh5hb1ar9v5r1ar9vy71czhvjz1e3am0v1e3g9vj1f790cf1f7emm71gbd05b1ijl0jj1ik1zb31jndr0f1jnjev31jo0cu71jo5z3z1krc4jj1krhrlr1lvai2n1lvg4cf1lvg54v1lvrf9b1lw8d8f1mzk4xr1mzk5q71mzpssf1mzvfun1o3o5j31o3zh8f1p7mjun1p7s64f1p7s6wv1p7xtz31p894vz1qbqkfz1qbw6pr1qbw7i71qc1trz1qc1ukf1qc7if31rfuk8v1rful1b1rg07b31rg5v5r1sjyku71sjylmn1sk47wf1sk48ov1skfitb1to2lfj1to2m7z1to88hr1to89a71todx4v1tojjen1ushwxrdcccccba9889baaabbcccc1nxgbbb1p1bk9556781r1o109a16231o157711111r1is671w1v1u1jk756521m1ow261h1z1q1i12888ba1g1s1188z1z1o1t138889b1l1o1886v1z1s1s19t8899bb1j87y1y1t1s1ar67u88c988161z1o1o19j111h1ee88881c201o1q18j551w20o565531y1o1s17m55231o1k411001o1x1owh3521201sn00031x1x13p33622201o18323581714i777231u1q1daa988912f98881fqlbbb999baaaaaaba888889a",
jungleLog: "0g0gn1appjpb1apv5z31bttkan1cxb27z1cxgohr1cxmbjz1cxrxtr1cxrym71e1f20v1e1f2tb1e1kp331e1qc5b1e1vyf31f5j2m71f5j3en1f5opof1f5uby71g9n37j1g9sphb1g9sq9r1hdr3sv1hdwq2n1hdwqv3368gmmgg2l2ll4lca68gi4gg6ibjmkmglb8g14jj5fgjmmmjj2ai24jiaijgemmljjhi68jgajjg4c9kgbglb64idiki464lij24g08jfhlj4g4mji04j0hkfhmm4l8mlj04lckl6idkhlfmjl74m8jk2gdimmmkhmldm4i96iehmmm4dmmkm9i8ikhhmmm9kmlkmhk9lhkjmhlmkglgmklhl8glm8im82djmmjmi4glm8h2368lmmcm28jlm8k1",
jungleLogTop: "0g0g01n1bttl331btz7cv1btz85b1cxxkvz1cy375r1cy37y71e1kp331e1vyf31e277r31f5j2m71f5opof1f5ucqn1f5zz0f1f6gw731g9sphb1g9sq9r1g9ycjj1ga3zlr1ga9mnz1gaf8xr1gaf9q71hdr3sv1hdwq2n1hdwqv31he2d4v1he80731heov0f1heovsv1heowlb1ii0qnz1ii0rgf1ii6dq71iina4f1iinawv1iiswe71iisx6n1jm4s1r1jmaebj1jmr9xb1jmrapr1jmrbi71jmwwzj1kqpo8v1kqpp1b1kr6jun1lutpmn1luzbwf1lv4y671lv4yyn1myxq7z1mz3chr1mz3da71mz8yrj1mz8zjz1o31qtb1o37d331o37dvj1o3d05b1p7bdofutatou1011iuguuuuuuuft21e1m1m1k1j143tgct6gux1j1313131213131cjnumtgx1e131h1j1j1j1j1ly1hkuuu51e131k1jrrrr181j131f3u71i131l1gy1l1m1m1jy1b1j1514oo1m131my1j1jyz1l1br1k131fo81m131jy1mz1h1bz1fq1jw1fhh1l131jy1mz1a1ay1er1is1f341k131my1j1cyz1k1jr1es1fbt1a131m1hy1k1k1m1gs1e1kw17tt11g161k1cy12y131j1hs1hcultk1e131j1m1k1j1k1fs1edatuumk1f1312ssss1jkmntetmt11d1k1j1k1j190n9fttuuuuuvpvvcut6tt",
junglePlanks: "0g0g0181lvg9331lvg9vj1lvlwxr1lvrjzz1lvrksf1mzemm71mzenen1mzk9of1mzkagv1mzpxj31mzvklb1n018fz1o3in7j1o3inzz1o3iosf1o3oa9r1o3ob271o3obun1o3ty4f1o3tywv1o3zl6n1o3zlz31o4588v1o4591b1o4aw3j1p7sbnj1p7xypr1p7xzi71p83lrz1p83mkf1p898u71p899mn1p8evwf1qc7mdb1qc7n5r1qcd9fj1qcda7z1qciwhr1qcixa71qcojjz1rgha0v1rgmx331rgmxvj1rgsk5b101310utds12171611xukxzxtttthstzyutsjttsllkjdgikmrrsktshhggh8ddfghjjjkk14yxdt111611yutkx151611uts7q10wuttl8xyuusli5dgijkkg2isgk1660000155656618q12151310i1fq10vwmk1ity1210tl6sxy1011wt3ranonba4lllssli1q888889766116556fzyytfp11111111tqdqsyyyusgqu1010uttdtxysssidprsstlicgjldddc6cdddeeddddd",
lapisBlock: "0g0gd05lnx8f06ps0zj06ps1rz07tw35r07u77r307u79bz07uil1b08ygw7308ys8ov0a31x4v0b6uiv30df83y70ejc5bz98999989cb868686878b78735733577197b8857757523754957877377853355497587555378a53749a77775535a7735197a757575235753495753555a5233524c535535375532774c533587353332371953237873575327185572235338753519753722332577530877533332335557163755533533357708111111510220000",
lapisOre: "0g0gy0k2c6bj0l6g64f0mak5xb0neo5q70neo6in0oimk1r0pmqjun0rv45q70sz86bj0u36jun0u3c64f0v7ajnj0v7g5xb0wbejgf0wbk5q70xfik1r0xfo6bj0yj58fz0yjmjun0yjs64f0zn3lz30zn988v0zn991b10r7mkf10rd8u710rd9mn11vbn5r11vh9fj11vha7z12zfnr312zla0v12zlatb1bwyjun1gd8ydbvuuuuutsrqqrtsssttuuuuxwi710sxjrnnxxqqqxf3ttsrppkkb50knopqrsxdpnon00kkloqqqr920qtsrqqqx91qq010qrtgx6qo62ooopqqrrttiqpomkkexf8qqqurqqx81ll4a8100qqq0032mnnn110nnonnmllkmnnnnnlkkkhhhxxa1mnxa0hhxhmk1cc4mo9a2nmxgnqqp11ppq110ssb1qrrqrqqqrstttt0rrtsssssstsqqqqqrs",
lightBlueConcrete: "0g0g3090ti4f090z4e70a4xipr2120111111121222222121122112211121121211112221221111102221122212112021111111122111112111112121211222221111122121212121112021122112211121211211111121220111212121111121222001122211222221022122111011221111111021211221211211121112212111111122121111211112222111",
lightBlueWool: "0g0gq090z4e70a4xipr0a534zj0a58r9b0b974sf0b9crun0b9ie4f0cdgrnj0cdmepr0cds0zj0dhqein0dhw0sf0dhw1kv0em01dr0em5nnj0fq9o8v0fqfain0gudou70gujb3z0hyhon30hynawv0hynbpb0j2lp8f0j2rbi70k6pptr0latpmn7b57fm89ik26ff63fippnkdd739d04benodepogdkojjppkifblodcfo8doofbpoie8fml21af95mm62428o817b81bd397cppmlffefnpidppkgbbppkioo79loiiookj4aoi8cad93fd55adcn22dh8ippejppookkpokiondfif6f68hhbcmj78ai22cicb22op51fmfjppi3jippokfd2ejoeeoppofdofilpn9agjc738og7copebio78no",
lightGrayConcrete: "0g0g20yjgg730yjggzj1000110001001010100010000000011101100010001001011010001100101010001000000000000010100000000100010100000000001010100010001000000000100000110000100001100000011101110001001011001001001001011000000000011001001001001010000000010000000010100110000000001000001001",
lightGrayWool: "0g0gi0yjgg730yjggzj0znkgsf0znkhkv10rohdr10roi6711vshz311vsirj11vy5tr12zwjcv12zwk5b1440jy7144670f1584kjj1584lbz16c8l4v16c8lxb17gclq745339e55bd1399329bhhfd7732570257ff78hfa7dfcchhdb95df769f57ff95hfb759ed115953ee31215f514551572537hhed9979fhb7hhda55hhdbff35dfbbgfdc25fb5657529733577f117b5bhh8chhfgddhfdbgf79b93935bb56ec355b117b6511fh319e9chhb2cbhhfd9718cf78fhhg97f9bdhf55ac6325fa36fh75bf35ff",
limeConcrete: "0g0g30ppd5a70ppirjz0qth5331121111111100111111111110111110111010211100110111211111211101111112111111111111101110111011110211011011110111110102111110100111000110112112110211112112112111212111111111111111011111011100101111111111212111111111112010011011221111111110111120011110111101111",
limeWool: "0g0gg0ppirjz0qth5330qtmrcv0rxl4vz0rxqr5r0t1p4ov0t1uqyn0u5t4hr0u5yqrj0v9x4an0va2qkf0we143j0xi53wf0ym3hfj0ym94hr10uh5of35237c44bb1299228affcb6632460257cd67ed96bdbbefba85bd657d46dd85fca748cb104942cc21214d403540562435ffcb7779cfb6ffb955ffbbdc34bdbaecbb24cb4546427622465c01694aff7bffcebbfdbbec69a728249955cb344a105a5501ce207c9bffa2bbefcb9607bd77dfee86d9abfc449b5324c935de75bc34cd",
magentaConcrete: "0g0g419jw2rj1anugan1ao02kf1ao03cv2233313332221332333333233213322333223332331233333313323103121223222131233211303233130230322231223302323103002220333103232232223333313231221331233333231232212303302330122232333333332123320111033031332321233232303322232223332223231233212323332233222231230323",
magentaWool: "0g0gs1ao02kf1ao03cv1brygvz1bs435r1bs43y71cw2hhb1cw83r31cw84jj1e06i2n1e0c4cf1e0c54v1f4ainz1f4g4xr1f4g5q71g8ej9b1g8k5j31g8k6bj1hcijun1hco64f1hco6wv1igmkfz1igs6pr1igs7i71jkw7b31jkw83j1kp08ov1lt49a71mxdwxr6945dl77ij14ff43ehrrmjba537a039cmoacqogajojjqrjhe9koa9do7booe9rnhc7elk118f74ll41317o7169719a275arrmkddcfmribrrjg99rrjion57koihonjj38ni798a72db448bam11bh7hrrcjrrnojjrojiomafhd4e47hh99lj578h11ah9911nq41dlfjrrh2jiqrnjfa1cjoccorqpebofhkrm78gj9537ng59oqc9in57mo",
mossyStoneBricks: "0g0gc0map24f0oigd8f0oj8bun0qqoef30qrlxq70sz21vj0v7wdtr0xf6vpb0xg4e7z0yjgikf11vskcf17g711bab4668864b88a680b9a28684a9999442ba926464996a2941b9792a679a979721b747794994697591a72497774642297075225752442277923310331110000333886bbba1abbbb6884aaaa991ba9aaaa6a99a9971b97a7a499aa99451b797992a99997471a689a97777574471a897799755224791722757753000031110003300",
netherBricks: "0g0g706o77cv08w9lhb0b4bzlr0dcedq70fkb4sf0gof6670iwn6kf0000000000000000556515666555165532340433333405333432133223321333000111000001110015666544155545540543333306433333143333221433243211000001110000014416641644164414330433063304330423143314321333140111011101110111464414666644166433330433344303333322033333330333",
netherQuartzOre: "0g0gc0hs27zz0m7vq4f0m81d6n0ncb0u70rsft330u2845b0v4m7sv10p0npb1bug2671e4e1vj1n1fv9b1smb9xb1312426644044643344320246610442164643068a921424676466baa866314246766ba8674662643166895678a8544641466565ba95146866310289856642b9742469b814466ab862467ba624646b952364a950268665602426852108b61623214642649a9164941364667689238976124667423804646442246624630246644",
netherrack: "0g0g70hs27zz0m7vq4f0m81d6n0ncb0u70rsft330v4m7sv10p0npb1312425544044543344320245210442154543012432142456545423545531424565424566455254315431566554244541452054554214565531024541154246642454221445541452456540245455112354554025655200242254210254102321454254122154541354556512234565124556423204545442245524530245544",
netherWartBlock: "0g0g60of09vj0suze9r0xana4f1539r7j1brbain1g7rcvz0122001222532010222235202110022112111222202202320122201003202242042220021211122103224300222201201022220122252002210210211223102220000221222200222022221132210202012201104100222102201012211021042230122022012022212012022002220222202202220234022205220322022302",
oakLog: "0g0gv1czno5b1cznoxr1e3m2gv1e3roqn1f73ke71f796nz1f7etq71f7q3271gb7k731gb7kzj1gbd79b1gbd81r1gbiubj1gboglb1gbu2v31gbu3nj1hfblkv1hfh7un1hfmuwv1hfsh6n1hfshz31ijl8fz1ijqupr1ijqvi71ijwhrz1ijwikf1jnp91b1jnp9tr1jnuvb31jnuw3j1kryvwf4d9muunj7t3tt8tjbd9jn8nmdndputuktdaj28nncljnuuuop7gn38oncnnmhuutnolndanjgnomafgtnejtf78nhntn6d8tnn25n09nhlto8j8uon15o1ltiluu8t9utp15tjqt7nhrltluntd8u9nt7mhnuuutlutgu8nadnhluuu8huuquan9ntnluuuatuttultatlsnultuqktnuqtnt9ntu9nu97hnuupun8ntu9n34datuuju79ntu9q2",
oakLogTop: "0g0g01i1czi1vj1cznoxr1e3m2gv1e3roqn1f7kfzz1f7q3271gb7k731gb7kzj1gbd79b1gboglb1gbohdr1gbu3nj1hfh7un1hfh8n31hfmuwv1hfsh6n1hfy48v1hg3qin1hg3rb31hg9dkv1ijl8fz1ijqupr1ijqvi71ijwhrz1ik24u71ik7r3z1ik7rwf1ikde671jnuvb31jnuw3j1jo0idb1joherj1kryvwf1krywov1ks4iyn1ks4jr31kslfcv1lwjtof1lwpfy71lwpgqn1n0nu9r1n0tgjj1n0z3lr1o4ru2n1o4ruv31o4xh4v1o534731p91hq71p973zz1p974sf1qd5ibj1qdb4lb1qdb5dr1rh9iwvwwctnwyzotfwwwwwwwkt11b1f1g1e1d122tfbt8fuv1d1518171718181dqmwmtev1c181f1f1f1e1f1f151drwww31d151f1d141213121c1f181b5w41b171g1d151f1g1g1e151c1f1810no1g171g151d1f15151g1d131f181bmb1f171d151g151c1a131d121d141ang1f171f151g151919121e141b121a231d181g151e1a15151f1g121a121aat16181h1e151f1e1h1f121d1f1311tt01f181f1c151515151d1d121e9wkti1d181f1g1d1d1d1b121ah8twwmj1d1814121212121fplmtcskt0191d1c1d1d140m7dttwwwwwxouxbww6tt",
oakPlanks: "0g0gs1ksft331lwe6m71lwjsvz1lwjtof1lwpfy71n0i77j1n0nthb1n0nu9r1n0tgjj1o4ruv31o4xh4v1o4xhxb1o534731p8vvgf1p91hq71p91iin1p974sf1qd5ibj1qdb4lb1qdb5dr1rh9iwv1rhf56n1rhf5z31rhks8v1sldji71slj5rz1slj6kf1tpn6dbnnjjh3glrrqjh7jnjhhee4ehomhga3hhaaaae8eaacaae7ec3345627777367377qoj7jmqokig7kqpojge8ghhhhga7kojhaae7heaa8997heaa3777773777738838jqoomg6hommmkf7hgklje97hjkmkhe7jda88884bbbabb87g3343073477773777qmmh7hqoqpkh7hmoomhg7hhjjgee7jjmbbec4eeeaeaa7eab3437177733333773",
orangeConcrete: "0g0g21p59iwv1q97wfz1011110111101111111011111110000111101110100111111110011111011001001101110110111111111110111111011111101110111111110111111111111111011110111101111011101101101111010010111111110110101110010011101111111010101001101111111011111110111111111001111111101111111111",
orangeWool: "0g0gm1q97wfz1rdbw8v1rdbx1b1rdhjb31shfwu71shfxmn1tljxfj1tljy7z1tlpkhr1upnytb1uptl331uptlvj1vtrzen1vtxlof1vtxmgv1wy1m9r1wy1n271wy79bz1wycwe71wyijgf1wyo5q71wytssf46239f55de02aa219dllhe8731570268hi79kib7eieelled96fi779i58ii96lhd859ff005a52ff20205i504650671537llgf998ahld8lleb66lledih35fiddihee25hd5757519822587h008c5dll9ellhieeliedih7ad92925cc67fe355d007d7600hk209faelld1edllhea709ei89ilkj98iadflh55be7315hb37il86dh35hi",
pinkConcrete: "0g0g31ltks8v1mxj5rz1mxj6kf1122212121112211111211211211122112111221111111121211212111122211111112112121112111111111111112111212221121111111212211112101110212211211122111211112212111211110211211211211111111121212221211121111112212211121211111211212211111111111121112111211212122122111",
pinkWool: "0g0gv1mxj6kf1o1hk3j1o1n6db1p5r6yn1q9v6rj1q9v7jz1rdz7cv1re4uf31si37y71si8u7z1tm78jj1tmcutb1tmcvlr1uqgven1uqmigv1uqs4qn1vuqj271vuw5bz1vuw64f1vv1se71vv7fgf1vvd1q71vvd2in1vviosf1vvipkv1vvobun1vvocn31vvtywv1vvzlz31vw588v1vw591b6a46em78jk25gg53fjuuokdc638c03adoqcesqhckqkktukjfalqcbeq7dqqfaupjd7fml219g83mm52327q716a71ac386buunleedgoujduukhaauukjqp68lqjjrpkk39pj7b9c83ed439dbo12di7juuekuuprkkuqkjrocgje5f57iiabmk679j22bjba12ps31emgkuuj3kjtupkgc1ekqdequssfdqgjluo89hkb637ph6bqtdajp67oq",
polishedAndesite: "0g0g90oilzi70sz23gf0v7a3270yjgjcv10ru60v11vyakf11w3ugv19okmwv1e4v30f7878888888788785843334442443134084444443376644307416763343446440844442456433334083344333424433318444634666554320833433332123444184562444466776608434433443344540844667633366444081444444664466208466654333134760844433334465334083333664444334406100000000110000",
polishedDiorite: "0g0g80qqu0ov0xfi5tr11vy6m71asubcv1f94t1b1jpkttr1o60w731ri7bpb7776677777666774764556657643564166764466577434506565333565454441675334576435457176544567733456607566767655346450744765756564534063556655467534516566544565544761664334655465666075673555775644517557654375466340745654576435744072445566545654512101110001100110",
polishedGranite: "0g0g90l56fi70plgu0v0yhw0sf1424tmn17eb8cf1aqna4f1e3al8f1e3x7un1jnje2n8888786866866565843344345444334374744554442446418444243334553342844444453344443262343344443734428345543644444431844444423445544263422344554433636444433443344442734444444464334284473344244442318455444445543341633443264434455264443444334447412111001110111100",
purpleConcrete: "0g0g40qo16v30rrzke70rrzl6n0rs57gf3222322033323333333312320220233231302222232332333202332233033330333322320012333323333330233022223332223332223232323303323233332332021220323110033223333322032332312323332322322202232223033232221223233023333332022233332332233232023333233223032323332323323332",
purpleWool: "0g0gm0rrzl6n0rs57gf0sw3kzj0sw3lrz0u01zb30u07lkv0u07mdb0v45zwf0w84dfj0w84e7z0xc8e0v0xc8etb0yg6scf0ygcem70zkasxr10o96gv10o979b10oetj311sd72711sd7un12wh8fz154uxhb47349e45ce13aa32acllfe8742570279fh79jhb7ehddkleca7eh779h48hha7lgc94aee116a52ee31214h414741771547llfe999aflc8lleb77llechg45ehcchged26gc4767519832687f118c4cll9dllgheelhechf7ac93a34cc77ed446c117c7711gj219eadllc1dcklgea719dh99hljia8hacelf56bd7424gb47hk97cg44fh",
quartzBlockBottom: "0g0g31sm5mv31tq9ngf1tqfbb32222221111000222121111000002222111100000012222110000001122221110001111000110000011100000110000011111222200001111222222211111111222211000112222220110012222222211222222222210000022222211000000222222110110112222111100112222221100101122222111101222222222210000",
quartzBlockSide: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov5555555555555555543333222224444153322222234444304222223344433330423333222332222153322222332222215333444422223330544444433333333054433222334444405332234444444430544444444432222154444433222222405444332332334440533322334444443042323344444333311100011111110000",
quartzBlockTop: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov5555555555555555543333222224444153322222234444304222223344433330423333222332222153322222332222215333444422223330544444433333333054433222334444405332234444444430544444444432222154444433222222405444332332334440533322334444443042323344444333311100011111110000",
quartzPillar: "0g0g41qe37y71sm5mv31tqfbb31uujcov0202031312130212020302130313031202131313120313020313130213031313131303120302121313020312031203131302131313020303120313031303130312130303131303120213131302131212131312130202120313021213120302031302120313031303130202130303131303120313031213120212131302121202",
quartzPillarTop: "0g0g51p9z6kf1qe37y71sm5mv31tqfbb31uujcov1021223242413020222122211221122002223434434322223123443344443211113412222221431242442344443244222243242222424423423324244142441222442424324234143244242211423322224423334432442421341222222143111123444444443213222234444443222002211222122112221203142423220200",
redConcrete: "0g0g112voa9r0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
redNetherBricks: "0g0g70c7i51b0efew3j0fjiwov0ive1a70nbiubj0svgd1b0v3ir5r0000000000000000556515666555165532340433333405333432133223321333000111000001110015666544155545540543333306433333143333221433243211000001110000014416641644164414330433063304330423143314321333140111011101110111464414666644166433330433344303333322033333330333",
redstoneBlock: "0g0g50v37dvj153407319j36671g74nwf1raof7j4444444444444444433433222334333443342202222232344332311001120234443211012011244443210000000042344302100000011134421100000000122442231000000111344324110210111234432110004001224443321101001110344322211111122224443124211022323443334433223333344444444444444444",
redstoneOre: "0g0g01c0yj58fz0zn3lz30zn988v0zn991b10r7mkf10rd8u710rd9mn11vbn5r11vh9fj11vha7z12zfnr312zla0v12zlatb1jjgvzz1lqws8v1lr2ein1lrox6n1mv0s1r1mv0su71mv6f3z1mvsxrz1nynunz1nz4tfj1nzafpb1p38t8f1p3egan1q7cttr1q7igvz1rc8zcv1rc905b1sgczy71sgd0qn1tjovlr1tjuhvj1unsw731unyj9b1uo45j31uo9tdr1uofgfz1uol14v1uol3i71uoqozj1uoqprz1wvjym71xzz9bz1y04we71y0ajgf1y0g6incbbbbba98778a999aabbbb1a1a16whe91bl844vv7771313oaa98661110pf145678918116454he11257771717ne7a9877717yi77ehe78a1415q75rn55567788aak765311111912y777b877ssj22pzxjee777eeon3444jhe4454432213444442111000ttzj34uzh00v031jggg35yzm43vd4776ii667ihe99dj7887877789aaaaf88a999999a97777789",
redWool: "0g0gd12voa9r13zmnsv153l1bz167jev3167p14v17bnenz18fls7319jprzz1ano5j31ano6bj1brmjun1brs64f1f3yku7241258227712662157cc9754212401459b45bb647b77bc77548b445b25bb54ca7525881036218821112b202420441224cc8855569c75cc7644cc77ba228b77ba7713a724342155113549015627cc57ccab77cb77b946752522664487223711474401ab105867cc7177bca764057b55bcbb55b678c923674212a624bb547a229b",
stone: "0g0gd0yj58fz0zn3lz30zn988v0zn991b10r7mkf10rd8u710rd9mn11vbn5r11vh9fj11vha7z12zfnr312zla0v12zlatbcbbbbba98778a999aabbbbaaaaaa98884456777889aa986611111145678987645421112577787777a987777887777778aa87755555567788aa77653111456777b87764322111456777754434444454454432213444442111000001134331000031111335676432347766666789a99877887877789aaaa888a999999a97777789",
mossyCobble: "0g0gb0muaccf0mupnnj0p38xdr0r0pekf0rbmj9b0un11q70w1wkxr0y07svz11vr5rz1a8mosf1ef1r0f4199211276438a9619a8812764813858398951644251118533852182851464110531183233866642a176895308948428981498852118851988111851664158385117641484642305126244558824124185442111155214698112124761318998127651764653885847488164588511858685851588531841183352111338a984",
stoneBricks: "0g0g70p2gyyn0rkrev30tj2nlr0xf9ou70zdjj0f12psrnj17g8flr5666666666665550645455555444445065454444445534406434554345434330632334544334324053244333345324302222222222222220110011000111111166666650566666663555544065455554544544306435354445544320634344454444343053345433332322305443344322222220222222221111110000111111",
tntTop: "0g0g704qh5a70nyecxr13jyl8f14a4flr1d4tukf1otd8u71szz8jj5665566556655665622462246224622462136210012300234431403344004433566006655660566562246204121402246211120000231023443341000111403356651000000506656211020001140224621360200120112344331031140344335661560500611665621462146124612462236223622362234433443344334433",
tntSides: "0g0ga07ipw5b0fbhzwf14a4flr1d4tukf1gwtvcv1ldqupr1otd8u71pk09vj1szz8jj1z141z38863886388638863663266326632663266326632663266326632663266326632663266326632663295775577755777799711071550711059745055115157177795717717115505479750571550550759444444444444444433223322332233226632663266326632663266326632663266326632663266323332333233323332",
tntBottom: "0g0g413jyl8f14a4flr1d4tukf1otd8u72332233223322332300130013001300130013001300130011111111111111111233223322332233230013001300130013001300130013001111111111111111123322332233223323001300130013001300130013001300111111111111111112332233223322332300130013001300130013001300130011111111111111111",
spruceLog: "0g0g60csc9vj0cskpof0dmmb5r0geuxof0lf4i670nnb4sf3243304330342431325130513034233130113051323223314031323131302341423130315131324343234232514232431323411343433243130343143341314332053314314141433325331331424303333431303132430332343130533053235233414051303313532343324132333343243340323224334324234232332431",
spruceLogTop: "0g0g80ix87pb0nnb4sf0p1n6db0qzu7zz0v5xypr0xy569r106bshr11ueyv31012101120110111066665657556666016223343444433711627766665666361153655555555645106465334433563501535525555355361154653533545645115465353353563510546535555455350153653323445645115465555555563510646656666676350164343333333336116665565575566611011101120110211",
sprucePlanks: "0g0g80nnb4sf0p1n6db0qzu7zz0v5xypr0xe36rj0xy569r106bshr11ueyv36567777767777762665523566655663356665643333556622112210011010010673777737776553656653532355666653356555266655333001121000011121067765577777777636566665333535332765533335555336300122100012110007367766377737677556633533665655553356532665333330110012221010000",
sand: "0g0g61m6x62n1nb9nnj1opn5dr1r80f7j1scbi0v1u0izgf4223213232132313122121130142502432011422222121122331213133132122125213232322122321223332123122121421151211022121212212212111242112322310131232124212221120212231202321232232012311223212331112121213132145321123323230232323221223235332323203223232332321223232",
whiteConcrete: "0g0g31ktui9r1ku04jj1lxyi2n1121212211221121111221111121122111211111121112111212112211111211212222111111221112211112101110211111122211211211111111212221111112212121212222111121122211111111222111111112121222121111111111211121221112221111121222121112212122111221211212111121221211221212",
whiteWool: "0g0gn1lxyi2n1lxyiv31ly454v1n22inz1n22jgf1n285q71o66j9b1o66k1r1o6c6bj1paajun1qeekfz1ricyrj1riil1b1smgykf1smmlmn1tqkz5r1tqqm7z1uuozr31uuumtb1vyt0cf1vyynen1x2x0xr1y711j37a56dj89hi26ee63egmmliba639a04acllacmlfailiimmigeajlaadl8blleamlgc8ejj219e94jj62429l817a81aa396ammkjddcelmhbmmifaammihll69jlhgllii49lh8a9a93db549bal12bg8gmmcimmlliimlihllaegd6e68ggaaji689g22agaa12lm41djeimmg3ihmmliea1cilcclmmmeblegjml99fia638lf6almcahl68ll",
yellowConcrete: "0g0g41to1w5b1us09of1us5vy71us5wqn2111111122222221232021021213122222211020112110121211022201012212122222312211221122213110202011133121132211112221221211211111112120231210211111201132001211212111211102220222021102211223011100222121202222222132111211111112111112021121120222221222011012122121",
yellowWool: "0g0gj1us5vy71usbj0f1vw9wjj1vwfitb1vwfjlr1vwl5vj1vwl6nz1vwqsxr1x0p6gv1x0utj31x10fsv1x10glb1x163nj1y54h6n1y5a48v1y5a51b1y5frb31y5fs3j1y5lf5r45239e44bc0299219biiec7731470158eg78hga7cgcchicb95dg759g47gg95ifb849ed005942ee20104g404540571436iied9989eib7iica55iicbgf34dgbbgfcc15fb4557419722576e007b4bii8ciifgccigcbge79b92924bb55ec345b006b5500fh209e9ciib1cbhifc9708cg88gihh97g9bdie45ac5314fa35gh85bf34eg",
smoothStone: "0g0g70wb8hdr0yjgikf12zwkxr17gcnb318kgnwf1asop331d0wq9r1011002200220121054556666553445204334454444555501666455566655442255444545666645006555555554343412556664665545550243343443434466116656545555455620555554566656661054544334454454215555666665566622444566454433452165445556555455104456665566544401022112221000121",
soulSand: "0g0g60egz94v0ht5n270k181z30oho3jz0sxyiv30xeekfz3130033202100434433135531100234004241451321012411423432542212230032442154212211332234104322433212002314322315332220023322345513032322211233445304302332013540423202342330242132302341043213032020354044321232020431445421112202350345131123302354202432103212415"
        };

    let blockData = [
        {
            name: "air",
            id: 0,
            textures: [],
            transparent: true,
            shadow: false,
        },
        {
            name: "grass",
            textures: [ "dirt", "grassTop", "grassSide" ],
        },
        { name: "dirt" },
        { name: "stone" },
        { name: "bedrock" },
        { name: "sand" },
        { name: "gravel" },
        {
            name: "leaves",
            transparent: true,
        },
        {
            name: "glass",
            transparent: true,
            shadow: false,
        },
        { name: "cobblestone" },
        { name: "mossyCobble" },
        { name: "stoneBricks" },
        { name: "mossyStoneBricks" },
        { name: "bricks" },
        { name: "coalOre" },
        { name: "ironOre" },
        { name: "goldOre" },
        { name: "diamondOre" },
        { name: "redstoneOre" },
        { name: "lapisOre" },
        { name: "emeraldOre" },
        { name: "coalBlock" },
        { name: "ironBlock" },
        { name: "goldBlock" },
        { name: "diamondBlock" },
        { name: "redstoneBlock" },
        { name: "lapisBlock" },
        { name: "emeraldBlock" },
        // { // I swear, if y'all don't stop asking about TNT every 5 minutes!
        //      name: "tnt",
        //      textures: ["tntBottom", "tntTop", "tntSides"]
        // },
        { name: "oakPlanks" },
        {
            name: "oakLog",
            textures: [ "oakLogTop", "oakLog" ],
        },
        { name: "acaciaPlanks" },
        {
            name: "acaciaLog",
            textures: [ "acaciaLogTop", "acaciaLog" ],
        },
        { name: "birchPlanks" },
        {
            name: "birchLog",
            textures: [ "birchLogTop", "birchLog" ],
        },
        { name: "darkOakPlanks" },
        {
            name: "darkOakLog",
            textures: [ "darkOakLogTop", "darkOakLog" ],
        },
        { name: "junglePlanks" },
        {
            name: "jungleLog",
            textures: [ "jungleLogTop", "jungleLog" ],
        },
        { name: "sprucePlanks" },
        {
            name: "spruceLog",
            textures: [ "spruceLogTop", "spruceLog" ],
        },
        { name: "whiteWool" },
        { name: "orangeWool" },
        { name: "magentaWool" },
        { name: "lightBlueWool" },
        { name: "yellowWool" },
        { name: "limeWool" },
        { name: "pinkWool" },
        { name: "grayWool" },
        { name: "lightGrayWool" },
        { name: "cyanWool" },
        { name: "purpleWool" },
        { name: "blueWool" },
        { name: "brownWool" },
        { name: "greenWool" },
        { name: "redWool" },
        { name: "blackWool" },
        { name: "whiteConcrete" },
        { name: "orangeConcrete" },
        { name: "magentaConcrete" },
        { name: "lightBlueConcrete" },
        { name: "yellowConcrete" },
        { name: "limeConcrete" },
        { name: "pinkConcrete" },
        { name: "grayConcrete" },
        { name: "lightGrayConcrete" },
        { name: "cyanConcrete" },
        { name: "purpleConcrete" },
        { name: "blueConcrete" },
        { name: "brownConcrete" },
        { name: "greenConcrete" },
        { name: "redConcrete" },
        { name: "blackConcrete" },
        {
            name: "bookshelf",
            textures: [ "oakPlanks", "bookshelf" ]
        },
        { name: "netherrack" },
        { name: "soulSand" },
        { name: "glowstone" },
        { name: "netherWartBlock" },
        { name: "netherBricks" },
        { name: "redNetherBricks" },
        { name: "netherQuartzOre" },
        {
            name: "quartzBlock",
            textures: ["quartzBlockBottom", "quartzBlockTop", "quartzBlockSide"]
        },
        {
            name: "quartzPillar",
            textures: ["quartzPillarTop", "quartzPillar"]
        },
        {
            name: "chiseledQuartzBlock",
            textures: ["chiseledQuartzBlock", "chiseledQuartzBlockTop"]
        },
        { name: "chiseledStoneBricks" },
        { name: "smoothStone" },
        { name: "andesite" },
        { name: "polishedAndesite" },
        { name: "diorite" },
        { name: "polishedDiorite" },
        { name: "granite" },
        { name: "polishedGranite" },
    ];

    //Set defaults on blockData
    (function() {
        for (let i = 1; i < blockData.length; i++) {
            let data = blockData[i];
            data.id = i;

            if (!data.textures) {
                data.textures = [ data.name, data.name, data.name, data.name, data.name, data.name ];
            } else if (typeof data.textures === "string") {
                let texture = data.textures;
                data.textures = [ texture, texture, texture, texture, texture, texture ];
            } else if (data.textures.length === 3) {
                data.textures[3] = data.textures[2];
                data.textures[4] = data.textures[2];
                data.textures[5] = data.textures[2];
            } else if (data.textures.length === 2) {
            // Top and bottom are the first texture, sides are the second.
                data.textures[2] = data.textures[1];
                data.textures[3] = data.textures[2];
                data.textures[4] = data.textures[2];
                data.textures[5] = data.textures[2];
                data.textures[1] = data.textures[0];
            }

            data.transparent = data.transparent || false;
            data.shadow = data.shadow !== undefined ? data.shadow : true;
        }
    })();

    let win = window.parent;
    let doc = document;
    let console = win.console;
    let world;

    let newFloat32Array = function(arr) {
        return new Float32Array(arr);
    };
    let newInt32Array = function(arr) {
        return new Int32Array(arr);
    };
    let newUint32Array = function(arr) {
        return new Uint32Array(arr);
    };
    let newUint8Array = function(arr) {
        return new Uint8Array(arr);
    };

    let seedHash;
    let hash = (function() {
        let seed = Math.random() * 2100000000 | 0;
        let PRIME32_2 = 1883677709;
        let PRIME32_3 = 2034071983;
        let PRIME32_4 = 668265263;
        let PRIME32_5 = 374761393;

        seedHash = function(s) {
            seed = s | 0;
        };

        return function(x, y) {
            let h32 = 0;

            h32 = seed + PRIME32_5 | 0;
            h32 += 8;

            h32 += Math.imul(x, PRIME32_3);
            h32 = Math.imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
            h32 += Math.imul(y, PRIME32_3);
            h32 = Math.imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

            h32 ^= h32 >> 15;
            h32 *= PRIME32_2;
            h32 ^= h32 >> 13;
            h32 *= PRIME32_3;
            h32 ^= h32 >> 16;

            return h32 / 2147483647;
        };
    })();
    let worldSeed;

    //The noise and random functions are copied from the processing.js source code; these others are polyfills made by me to avoid needing to remove all the pjs draw calls
    let currentRandom = null;
    function Marsaglia(i1, i2) {
    // from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c
        let z = (i1 | 0) || 362436069, w = i2 || hash(521288629, z) * 2147483647 | 0;

        let nextInt = function() {
            z=36969*(z&65535)+(z>>>16) & 0xFFFFFFFF;
            w=18000*(w&65535)+(w>>>16) & 0xFFFFFFFF;
            return ((z&0xFFFF)<<16 | w&0xFFFF) & 0xFFFFFFFF;
        };

        this.nextDouble = function() {
            let i = nextInt() / 4294967296;
            return i < 0 ? 1 + i : i;
        };
        this.nextInt = nextInt;
    }
    let randomSeed = function(seed) {
        currentRandom = (new Marsaglia(seed)).nextDouble;
    }
    let random = function(min, max) {
        if (!max) {
            if (min) {
                max = min;
                min = 0;
            } else {
                min = 0;
                max = 1;
            }
        }
        return currentRandom() * (max - min) + min;
    }
    let noiseProfile = { generator: undefined, octaves: 4, fallout: 0.5, seed: undefined };
    function PerlinNoise(seed) {
        let rnd = seed !== undefined ? new Marsaglia(seed) : Marsaglia.createRandomized();
        let i, j;
        // http://www.noisemachine.com/talk1/17b.html
        // http://mrl.nyu.edu/~perlin/noise/
        // generate permutation
        let perm = new Uint8Array(512);
        for(i=0;i<256;++i) {
            perm[i] = i;
        }
        for(i=0;i<256;++i) {
            let t = perm[j = rnd.nextInt() & 0xFF]; perm[j] = perm[i]; perm[i] = t;
        }
        // copy to avoid taking mod in perm[0];
        for(i=0;i<256;++i) {
            perm[i + 256] = perm[i];
        }

        function grad3d(i,x,y,z) {
            let h = i & 15; // convert into 12 gradient directions
            let u = h<8 ? x : y,
                v = h<4 ? y : h===12||h===14 ? x : z;
            return ((h&1) === 0 ? u : -u) + ((h&2) === 0 ? v : -v);
        }

        function grad2d(i,x,y) {
            let v = (i & 1) === 0 ? x : y;
            return (i&2) === 0 ? -v : v;
        }

        function grad1d(i,x) {
            return (i&1) === 0 ? -x : x;
        }

        function lerp(t,a,b) {
            return a + t * (b - a);
        }

        this.noise3d = function(x, y, z) {
            let X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
            x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
            let fx = (3-2*x)*x*x, fy = (3-2*y)*y*y, fz = (3-2*z)*z*z;
            let p0 = perm[X]+Y, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z,
                p1 = perm[X + 1] + Y, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;
            return lerp(fz,
                lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x-1, y, z)),
                    lerp(fx, grad3d(perm[p01], x, y-1, z), grad3d(perm[p11], x-1, y-1,z))),
                lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z-1), grad3d(perm[p10 + 1], x-1, y, z-1)),
                    lerp(fx, grad3d(perm[p01 + 1], x, y-1, z-1), grad3d(perm[p11 + 1], x-1, y-1,z-1))));
        };

        this.noise2d = function(x, y) {
            let X = Math.floor(x)&255, Y = Math.floor(y)&255;
            x -= Math.floor(x); y -= Math.floor(y);
            let fx = (3-2*x)*x*x, fy = (3-2*y)*y*y;
            let p0 = perm[X]+Y, p1 = perm[X + 1] + Y;
            return lerp(fy,
                lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x-1, y)),
                lerp(fx, grad2d(perm[p0 + 1], x, y-1), grad2d(perm[p1 + 1], x-1, y-1)));
        };

        this.noise1d = function(x) {
            let X = Math.floor(x)&255;
            x -= Math.floor(x);
            let fx = (3-2*x)*x*x;
            return lerp(fx, grad1d(perm[X], x), grad1d(perm[X+1], x-1));
        };
    }
    let noiseSeed = function(seed) {
        noiseProfile.seed = seed;
        noiseProfile.generator = new PerlinNoise(noiseProfile.seed);
    };
    let noise = function(x, y, z) {
        let generator = noiseProfile.generator;
        let effect = 1, k = 1, sum = 0;
        for(let i = 0; i < noiseProfile.octaves; ++i) {
            effect *= noiseProfile.fallout;
            switch (arguments.length) {
                case 1:
                    sum += effect * (1 + generator.noise1d(k*x))/2; break;
                case 2:
                    sum += effect * (1 + generator.noise2d(k*x, k*y))/2; break;
                case 3:
                    sum += effect * (1 + generator.noise3d(k*x, k*y, k*z))/2; break;
            }
            k *= 2;
        }
        return sum;
    };

    let caveNoise;
    // Copied and modified from https://github.com/blindman67/SimplexNoiseJS
    function openSimplexNoise(clientSeed) {
        const SQ4 = 2;
        const toNums = function(s) { return s.split(",").map(function(s) { return new Uint8Array(s.split("").map(function(v) { return Number(v) })) }) };
        const decode = function(m, r, s) { return new Int8Array(s.split("").map(function(v) { return parseInt(v, r) + m })) };
        const toNumsB32 = function(s) { return s.split(",").map(function(s) { return parseInt(s, 32) }) };
        const NORM_3D = 1.0 / 206.0;
        const SQUISH_3D = 1 / 3;
        const STRETCH_3D = -1 / 6;
        var base3D = toNums("0000110010101001,2110210120113111,110010101001211021012011");
        const gradients3D = decode(-11, 23, "0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70");
        var lookupPairs3D = function() { return new Uint16Array(toNumsB32("0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6")) };
        var p3D = decode(-1, 5, "112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131");
        const setOf = function(count) { var a = [],i = 0; while (i < count) { a.push(i++) } return a };
        const doFor = function(count, cb) { var i = 0; while (i < count && cb(i++) !== true) {} };

        function shuffleSeed(seed,count){
            seed = seed * 1664525 + 1013904223 | 0;
            count -= 1;
            return count > 0 ? shuffleSeed(seed, count) : seed;
        }
        const types = {
            _3D : {
                base : base3D,
                squish : SQUISH_3D,
                dimensions : 3,
                pD : p3D,
                lookup : lookupPairs3D,
            }
        };

        function createContribution(type, baseSet, index) {
            var i = 0;
            const multiplier = baseSet[index ++];
            const c = { next : undefined };
            while(i < type.dimensions) {
                const axis = ("xyzw")[i];
                c[axis + "sb"] = baseSet[index + i];
                c["d" + axis] = - baseSet[index + i++] - multiplier * type.squish;
            }
            return c;
        }

        function createLookupPairs(lookupArray, contributions){
            var i;
            const a = lookupArray();
            const res = new Map();
            for (i = 0; i < a.length; i += 2) { res.set(a[i], contributions[a[i + 1]]); }
            return res;
        }

        function createContributionArray(type) {
            const conts = [];
            const d = type.dimensions;
            const baseStep = d * d;
            var k, i = 0;
            while (i < type.pD.length) {
                const baseSet = type.base[type.pD[i]];
                let previous, current;
                k = 0;
                do {
                    current = createContribution(type, baseSet, k);
                    if (!previous) { conts[i / baseStep] = current; }
                    else { previous.next = current; }
                    previous = current;
                    k += d + 1;
                } while(k < baseSet.length);

                current.next = createContribution(type, type.pD, i + 1);
                if (d >= 3) { current.next.next = createContribution(type, type.pD, i + d + 2) }
                if (d === 4) { current.next.next.next = createContribution(type, type.pD, i + 11) }
                i += baseStep;
            }
            const result = [conts, createLookupPairs(type.lookup, conts)];
            type.base = undefined;
            type.lookup = undefined;
            return result;
        }

        let temp = createContributionArray(types._3D);
        const contributions3D = temp[0], lookup3D = temp[1];
        const perm = new Uint8Array(256);
        const perm3D = new Uint8Array(256);
        const source = new Uint8Array(setOf(256));
        var seed = shuffleSeed(clientSeed, 3);
        doFor(256, function(i) {
            i = 255 - i;
            seed = shuffleSeed(seed, 1);
            var r = (seed + 31) % (i + 1);
            r += r < 0 ? i + 1 : 0;
            perm[i] = source[r];
            perm3D[i] = (perm[i] % 24) * 3;
            source[r] = source[i];
        });
        base3D = undefined;
        lookupPairs3D = undefined;
        p3D = undefined;

        return function(x, y, z) {
            const pD = perm3D;
            const p = perm;
            const g = gradients3D;
            const stretchOffset = (x + y + z) * STRETCH_3D;
            const xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset;
            const xsb = Math.floor(xs), ysb = Math.floor(ys), zsb = Math.floor(zs);
            const squishOffset    = (xsb + ysb + zsb) * SQUISH_3D;
            const dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset);
            const xins = xs - xsb, yins = ys - ysb, zins = zs - zsb;
            const inSum = xins + yins + zins;
            var c = lookup3D.get(
                (yins - zins + 1) |
                ((xins - yins + 1) << 1) |
                ((xins - zins + 1) << 2) |
                (inSum << 3) |
                ((inSum + zins) << 5) |
                ((inSum + yins) << 7) |
                ((inSum + xins) << 9)
            );
            var i, value = 0;
            while (c !== undefined) {
                const dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz;
                let attn = 2 - dx * dx - dy * dy - dz * dz;
                if (attn > 0) {
                    i = pD[(((p[(xsb + c.xsb) & 0xFF] + (ysb + c.ysb)) & 0xFF) + (zsb + c.zsb)) & 0xFF];
                    attn *= attn;
                    value += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz);
                }
                c = c.next;
            }
            return value * NORM_3D + 0.5;
        }
    }

    let PVector = function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.set = function(x, y, z) {
            if (y === undefined) {
                this.x = x.x;
                this.y = x.y;
                this.z = x.z;
            } else {
                this.x = x;
                this.y = y;
                this.z = z;
            }
        }
        this.normalize = function() {
            let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            this.x /= mag;
            this.y /= mag;
            this.z /= mag;
        }
        this.add = function(v) {
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
        }
        this.mult = function(m) {
            this.x *= m;
            this.y *= m;
            this.z *= m;
        }
    }
    let fill = function(r, g, b) {
        if (g === undefined) {
            g = r;
            b = r;
        }
        ctx.fillStyle = "rgb(" + r + ", " + g + ", " + b + ")"
    }
    let stroke = function(r, g, b) {
        if (g === undefined) {
            g = r;
            b = r;
        }
        ctx.strokeStyle = "rgb(" + r + ", " + g + ", " + b + ")"
    }
    let line = function(x1, y1, x2, y2) {
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
    }
    function fastText(txt, x, y, h) {
        h = h || 0;

        let lines = txt.split("\n");
        for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], x, y + h * i);
        }
    }
    function textSize(size) {
        ctx.font = size + 'px Monospace';
    }
    let text = fastText;
    let strokeWeight = function(num) {
        ctx.lineWidth = num;
    }
    let ARROW = "arrow";
    let HAND = "pointer";
    let CROSS = "crosshair";
    let cursor = function(type) {
        canvas.style.cursor = type;
    }
    randomSeed(Math.random() * 10000000 | 0);

    //globals
    //{
    let fov = 70; // Field of view in degrees
    let version = "Alpha 0.6.1";
    let reach = 5; // Max distance player can place or break blocks

    let blockIds = {};
    blockData.forEach(function(block) {
        blockIds[block.name] = block.id;
    });

    let currentFov, targetFov, fovTime;
    let renderDistance = 4;
    let locked = true;
    let generatedChunks;
    let mouseX, mouseY;
    let width = window.innerWidth;
    let height = window.innerHeight;
    let generator = {
        height: 80, // Height of the hills
        smooth: 0.01, // Smoothness of the terrain
        extra: 30, // Extra height added to the world.
        caveSize: 0.00 // Redefined right above where it's used
    };
    let maxHeight = 255;
    let blockOutlines = false;
    let blockFill = true;
    let updateHUD = true;
    const SLAB = 1;
    const CUBE = 0;
    let blockMode = CUBE;
    let textureMap;
    let textureCoords;
    let texCoordsBuffers;
    let bigArray = win.bigArray || newFloat32Array(200000);
    win.bigArray = bigArray;

    let screen;
    let hitBox = {};
    let holding = 0;
    let Key = {};
    let modelView = win.modelView || newFloat32Array(16);
    win.modelView = modelView;
    let glCache;
    let nearH;
    let freezeFrame = 0;
    let p;
    let vec1 = new PVector(), vec2 = new PVector(), vec3 = new PVector();
    let move = {
        x: 0,
        y: 0,
        z: 0,
        ang: Math.sqrt(0.5),
    };
    let p2 = {
        x: 0,
        y: 0,
        z: 0,
    };
    let place;
    let inventory = {
        hotbar: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
        main: [],
        hotbarSlot: 0,
        size: 40,
        holding: 0,
    };

    //}


    function play() {
        screen = "play";
        getPointer();
        fill(255, 255, 255);
        textSize(10);
        p.lastBreak = Date.now();
        updateHUD = true;
        gl.clearColor(84 / 255, 138 / 255, 184 / 255, 1.0);
        savebox.hidden = true;
        saveDirections.hidden = true;
        message.hidden = true;
    }

    let gl;
    function getPointer() {
        if (canvas.requestPointerLock) {
            canvas.requestPointerLock();
        }
    }
    function releasePointer() {
        if (doc.exitPointerLock) {
            doc.exitPointerLock();
        }
    }


    let Block = {
        top: 0x4,
        bottom: 0x8,
        north: 0x20,
        south: 0x10,
        east: 0x2,
        west: 0x1,
    };
    let Sides = {
        top: 0,
        bottom: 1,
        north: 2,
        south: 3,
        east: 4,
        west: 5,
    };

    //GLSL Shader code
    //{
    let vertexShaderSrc3D = ""
    + "varying float vShadow;"
    + "attribute vec3 aVertex;"
    + "attribute vec2 aTexture;"
    + "attribute float aShadow;"
    + "varying   vec2 vTexture;"
    + "uniform vec4 uColor;"
    + "uniform mat4 uView;"
    + "uniform mat4 uProjection;"
    + "uniform bool uEdge;"

    + "void main(void) {"
    + "  vTexture = aTexture;"
    + "  vShadow = aShadow > 0.0 ? aShadow : 1.0;"
    + "  gl_Position = uView * vec4( aVertex, 1.0 );"

    //"  vShadow = 1.0;"+// - gl_Position.z / 10000.0;" +
    + "}";

    let fragmentShaderSrc3D = ""
    + "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    + "  precision highp float;\n"
    + "#else\n"
    + "  precision mediump float;\n"
    + "#endif\n"

    + "varying float vShadow;"

    + "uniform sampler2D uSampler;"
    + "varying vec2 vTexture;"

    + "void main(void){"
    + "  vec4 color = texture2D(uSampler, vTexture);"
    + "  gl_FragColor = vec4(color.rgb * vShadow, color.a);"
    + "  if (gl_FragColor.a == 0.0) discard;"
    + "}";
    //}

    let createProgramObject = function(curContext, vetexShaderSource, fragmentShaderSource) {
        let vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER);
        curContext.shaderSource(vertexShaderObject, vetexShaderSource);
        curContext.compileShader(vertexShaderObject);
        if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {
            throw curContext.getShaderInfoLog(vertexShaderObject);
        }

        let fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER);
        curContext.shaderSource(fragmentShaderObject, fragmentShaderSource);
        curContext.compileShader(fragmentShaderObject);
        if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {
            throw curContext.getShaderInfoLog(fragmentShaderObject);
        }

        let programObject = curContext.createProgram();
        curContext.attachShader(programObject, vertexShaderObject);
        curContext.attachShader(programObject, fragmentShaderObject);
        curContext.linkProgram(programObject);
        if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {
            throw "Error linking shaders.";
        }

        return programObject;
    };

    let programObject3D;
    let baseTextureVertices = [
        [ 1, 0, 0, 0, 0, 1, 1, 1 ],
        [ 1, 0, 0, 0, 0, 1, 1, 1 ],
        [ 1, 0, 0, 0, 0, 1, 1, 1 ],
        [ 1, 0, 0, 0, 0, 1, 1, 1 ],
        [ 0, 1, 0, 0, 1, 0, 1, 1 ],
        [ 0, 1, 0, 0, 1, 0, 1, 1 ]
    ]
    let shapes = {
        /*
            [
                [[west, bottom, south, east, bottom, south, east, bottom, north, west, bottom, north]],
                [[west, top,    south, west, top,    north, east, top,    north, east, top,    south]],
                [[east, top,    north, west, top,    north, west, bottom, north, east, bottom, north]],
                [[west, top,    south, east, top,    south, east, bottom, south, west, bottom, south]],
                [[]],
                [[]]
            ]
            [
                [(-x, -z), (+x, -z), (+x, +z), (-x, +z)], // minX = 0,  minZ = 2,  maxX = 6, maxZ = 8
                [(-x, -z), (-x, +z), (+x, +z), (+x, -z)], // minX = 0,  minZ = 2,  maxX = 6, maxZ = 8
                [(+x, +y), (-x, +y), (-x, -y), (+x, -y)], // minX = 6,  minY = 7,  maxX = 0, maxY = 1
                [(-x, +y), (+x, +y), (+x, -y), (-x, -y)], // minX = 9,  minY = 10, maxX = 3, maxY = 4
                [(+y, -z), (+y, +z), (-y, +z), (-y, -z)], // minY = 10, minZ = 11, maxY = 4, maxZ = 5
                [(+y, +z), (+y, -z), (-y, -z), (-y, +z)]  // minY = 7,  minZ = 8,  maxY = 1, maxZ = 2
            ]
            */
        cube: {
            verts: [
                [[ -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5 ]], //bottom
                [[ -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5 ]], //top
                [[  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5 ]], //north
                [[ -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5 ]], //south
                [[  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5 ]], //east
                [[ -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5 ]]  //west
            ],
            texVerts: [],
            buffer: null,
            size: 6
        },
        slab: {
            verts: [
                [[ -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5 ]], //bottom
                [[ -0.5,  0.0, -0.5, -0.5,  0.0,  0.5,  0.5,  0.0,  0.5,  0.5,  0.0, -0.5 ]], //top
                [[  0.5,  0.0,  0.5, -0.5,  0.0,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5 ]], //north
                [[ -0.5,  0.0, -0.5,  0.5,  0.0, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5 ]], //south
                [[  0.5,  0.0, -0.5,  0.5,  0.0,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5 ]], //east
                [[ -0.5,  0.0,  0.5, -0.5,  0.0, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5 ]]  //west
            ],
            texVerts: [],
            buffer: null,
            size: 6
        }
    };
    function initShapes() {
        function mapCoords(verts, index, obj, x, y, z) {
            let cx = 0;
            let cy = 0;
            let n = 0;
            let texArrayOuter = [];
            let baseArr = shapes.cube.verts[index][0];
            const texWidth = 1 / 16;
            const abs = Math.abs;
            verts[index].forEach(function(arr) {
                let texArr = []
                for (let i = 0, j = 0; i < arr.length;) {
                    if (x) cx = abs(baseTextureVertices[index][j++] - abs(baseArr[i] - arr[i])) * texWidth;
                    i++;
                    if (y) cy = abs(baseTextureVertices[index][j++] - abs(baseArr[i] - arr[i])) * texWidth;
                    i++;
                    if (z) {
                        n = abs(baseTextureVertices[index][j++] - abs(baseArr[i] - arr[i])) * texWidth;
                        if (y) cx = n;
                        else cy = n;
                    }
                    i++
                    texArr.push(cx, cy);
                }
                texArrayOuter.push(texArr);
            })
            obj.texVerts.push(texArrayOuter);
        }

        for (let shape in shapes) {
            let obj = shapes[shape];
            let verts = obj.verts;

            mapCoords(verts, 0, obj, true, false, true);
            mapCoords(verts, 1, obj, true, false, true);
            mapCoords(verts, 2, obj, true, true, false);
            mapCoords(verts, 3, obj, true, true, false);
            mapCoords(verts, 4, obj, false, true, true);
            mapCoords(verts, 5, obj, false, true, true);

            obj.buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, newFloat32Array(verts.flat(2)), gl.STATIC_DRAW);
        }
    }
    let indexOrder;
    (function() {
        let arr = [];
        for (let i = 0; i < 40000; i++) {
            arr.push(0 + i * 4, 1 + i * 4, 2 + i * 4, 0 + i * 4, 2 + i * 4, 3 + i * 4);
        }
        indexOrder = newUint32Array(arr);
    })();

    let hexagonVerts;
    let slabIconVerts;
    let blockIcons;
    (function() {
        let side = Math.sqrt(3) / 2;
        hexagonVerts = newFloat32Array([
            0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
            0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
            -side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
        ]);
        slabIconVerts = newFloat32Array([
            0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
            0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
            -side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
        ]);
    })();
    function genIcons() {
        blockIcons = [null];
        let texOrder = [ 1, 2, 3 ];
        let shadows = [ 1, 0.7, 0.4 ];
        let scale = 0.16 / height * inventory.size;
        for (let i = 1; i < blockData.length; i++) {
            let data = [];
            let block = blockData[i];
            for (let j = 0; j < 12; j++) {
                data.push(hexagonVerts[j * 3 + 0] * scale);
                data.push(hexagonVerts[j * 3 + 1] * scale);
                data.push(0.1666666);
                data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 0) % 8]);
                data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 1) % 8]);
                data.push(shadows[Math.floor(j / 4)]);
            }
            let buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, newFloat32Array(data), gl.STATIC_DRAW);
            blockIcons[i] = buffer;

            data = [];
            for (let j = 0; j < 12; j++) {
                data.push(slabIconVerts[j * 3 + 0] * scale);
                data.push(slabIconVerts[j * 3 + 1] * scale);
                data.push(0.1666666);
                data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 0) % 8]);
                data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 1) % 8]);
                data.push(shadows[Math.floor(j / 4)]);
            }
            buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, newFloat32Array(data), gl.STATIC_DRAW);
            blockIcons[i | 128] = buffer;
        }
    }

    function uniformMatrix(cacheId, programObj, vrName, transpose, matrix) {
        let vrLocation = glCache.locations[cacheId];
        if(vrLocation === undefined) {
            vrLocation = gl.getUniformLocation(programObj, vrName);
            glCache.locations[cacheId] = vrLocation;
        }
        gl.uniformMatrix4fv(vrLocation, transpose, matrix);
    }
    function vertexAttribPointer(cacheId, programObj, vrName, size, VBO) {
        let vrLocation = glCache.locations[cacheId];
        if(vrLocation === undefined) {
            vrLocation = gl.getAttribLocation(programObj, vrName);
            glCache.locations[cacheId] = vrLocation;
        }
        if (vrLocation !== -1) {
            gl.enableVertexAttribArray(vrLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
            gl.vertexAttribPointer(vrLocation, size, gl.FLOAT, false, 0, 0);

        }
    }

    //Generate buffers for every block face and store them
    let sideEdgeBuffers;
    let indexBuffer;

    /** Matrix and Vector transformation methods **/
    //{
    let matrix = newFloat32Array(16);
    let projection = win.projection || newFloat32Array(16);
    win.projection = projection;
    function trans(matrix, x, y, z) {
        let a = matrix;
        a[3] += a[0] * x + a[1] * y + a[2] * z;
        a[7] += a[4] * x + a[5] * y + a[6] * z;
        a[11] += a[8] * x + a[9] * y + a[10] * z;
        a[15] += a[12] * x + a[13] * y + a[14] * z;
    }
    function rotX(matrix, angle) {
    // source = [1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]
        let elems = matrix;
        let c = Math.cos(angle);
        let s = Math.sin(angle);
        let t = elems[1];
        elems[1] = t * c + elems[2] * s;
        elems[2] = t * -s + elems[2] * c;
        t = elems[5];
        elems[5] = t * c + elems[6] * s;
        elems[6] = t * -s + elems[6] * c;
        t = elems[9];
        elems[9] = t * c + elems[10] * s;
        elems[10] = t * -s + elems[10] * c;
        t = elems[13];
        elems[13] = t * c + elems[14] * s;
        elems[14] = t * -s + elems[14] * c;
    }
    function rotY(matrix, angle) {
    //source = c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1
        let c = Math.cos(angle);
        let s = Math.sin(angle);
        let elems = matrix;
        let t = elems[0];
        elems[0] = t * c + elems[2] * -s;
        elems[2] = t * s + elems[2] * c;
        t = elems[4];
        elems[4] = t * c + elems[6] * -s;
        elems[6] = t * s + elems[6] * c;
        t = elems[8];
        elems[8] = t * c + elems[10] * -s;
        elems[10] = t * s + elems[10] * c;
        t = elems[12];
        elems[12] = t * c + elems[14] * -s;
        elems[14] = t * s + elems[14] * c;
    }
    function transpose(matrix) {
        let temp = matrix[4];
        matrix[4] = matrix[1];
        matrix[1] = temp;

        temp = matrix[8];
        matrix[8] = matrix[2];
        matrix[2] = temp;

        temp = matrix[6];
        matrix[6] = matrix[9];
        matrix[9] = temp;

        temp = matrix[3];
        matrix[3] = matrix[12];
        matrix[12] = temp;

        temp = matrix[7];
        matrix[7] = matrix[13];
        matrix[13] = temp;

        temp = matrix[11];
        matrix[11] = matrix[14];
        matrix[14] = temp;
    }
    function matMult() {
    //Multiply the projection matrix by the view matrix; this is optimized specifically for these matrices by removing terms that are always 0.
        let proj = projection;
        let view = modelView;
        matrix[0] = proj[0] * view[0];
        matrix[1] = proj[0] * view[1];
        matrix[2] = proj[0] * view[2];
        matrix[3] = proj[0] * view[3];
        matrix[4] = proj[5] * view[4];
        matrix[5] = proj[5] * view[5];
        matrix[6] = proj[5] * view[6];
        matrix[7] = proj[5] * view[7];
        matrix[8] = proj[10] * view[8] + proj[11] * view[12];
        matrix[9] = proj[10] * view[9] + proj[11] * view[13];
        matrix[10] = proj[10] * view[10] + proj[11] * view[14];
        matrix[11] = proj[10] * view[11] + proj[11] * view[15];
        matrix[12] = proj[14] * view[8];
        matrix[13] = proj[14] * view[9];
        matrix[14] = proj[14] * view[10];
        matrix[15] = proj[14] * view[11];
    }
    function copyArr(a, b) {
        for (let i = 0; i < a.length; i++) {
            b[i] = a[i];
        }
    }
    function FOV(fov) {
        let tang = Math.tan(fov * 0.5 * Math.PI / 180);
        let scale = 1 / tang;
        let near = 1;
        let far = 1000000;
        currentFov = fov;
        nearH = near * tang;

        projection[0] = scale / width * height;
        projection[5] = scale;
        projection[10] = -far / (far - near);
        projection[11] = -1;
        projection[14] = -far * near / (far - near);

    // Set the projecction matrix in the shader
    // copyArr(projection, matrix);
    // transpose(matrix);
    // uniformMatrix("projection3d", programObject3D, "uProjection", false, matrix);
    }
    function cross(v1, v2, result) {
        let x = v1.x,
            y = v1.y,
            z = v1.z,
            x2 = v2.x,
            y2 = v2.y,
            z2 = v2.z;
        result.x = y * z2 - y2 * z;
        result.y = z * x2 - z2 * x;
        result.z = x * y2 - x2 * y;
    }
    //}

    function Plane(nx, ny, nz) {
        this.dx = nx > 0 ? 16 : 0;
        this.dy = ny > 0;
        this.dz = nz > 0 ? 16 : 0;

        // Normal vector
        this.nx = nx;
        this.ny = ny;
        this.nz = nz;
    }
    Plane.prototype.set = Plane;
    function computeFrustum() {
        let X = vec1;
        X.x = p.direction.z;
        X.y = 0
        X.z = -p.direction.x;
        X.normalize();

        let Y = vec2;
        Y.set(p.direction);
        Y.mult(-1);
        cross(Y, X, Y);

        //Near plane (hoisted to outside the render loop to improve performance)
        // var x = p.x + p.direction.x;
        // var y = p.y + p.direction.y;
        // var z = p.z + p.direction.z;
        // p.frustum[0].set(x, y, z, p.direction.x, p.direction.y, p.direction.z);

        let aux = vec3;
        aux.set(Y);
        aux.mult(nearH);
        aux.add(p.direction);
        aux.normalize();
        cross(aux, X, aux);
        p.frustum[0].set(aux.x, aux.y, aux.z);

        aux.set(Y);
        aux.mult(-nearH);
        aux.add(p.direction);
        aux.normalize();
        cross(X, aux, aux);
        p.frustum[1].set(aux.x, aux.y, aux.z);

        aux.set(X);
        aux.mult(-nearH * width / height);
        aux.add(p.direction);
        aux.normalize();
        cross(aux, Y, aux);
        p.frustum[2].set(aux.x, aux.y, aux.z);

        aux.set(X);
        aux.mult(nearH * width / height);
        aux.add(p.direction);
        aux.normalize();
        cross(Y, aux, aux);
        p.frustum[3].set(aux.x, aux.y, aux.z);
    }
    let chunkVisible = function(x, y, z, maxY) {
        x -= 0.5;
        y -= 0.5;
        z -= 0.5;
        maxY += 0.5;
        let px = 0, py = 0, pz = 0, plane = null;
        let cx = p.x, cy = p.y, cz = p.z;
        for (let i = 0; i < 4; i++) {
            plane = p.frustum[i];
            px = x + plane.dx;
            py = plane.dy ? maxY : y;
            pz = z + plane.dz;
            if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
                return false;
            }
        }
        return true;
    };

    let defaultModelView = newFloat32Array([ -10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1 ]);
    let initModelView = function(x, y, z, rx, ry) {
        copyArr(defaultModelView, modelView);
        rotX(modelView, rx);
        rotY(modelView, ry);
        trans(modelView, -x, -y, -z);
        matMult();
        transpose(matrix);
        uniformMatrix("view3d", programObject3D, "uView", false, matrix);
    };
    let tex;

    function roundBits(number) {
        return Math.round(number * 1000000) / 1000000;
    }
    function rayTrace(x, y, z, shape) {
        let cf, cd = 1e9; //Closest face and distance
        let m; //Absolute distance to intersection point
        let ix, iy, iz; //Intersection coords
        let minX, miny, minz, maxX, maxY, maxZ; //Bounds of face coordinates
        let east = p.direction.x < 0;
        let top = p.direction.y < 0;
        let north = p.direction.z < 0;
        let verts = shape.verts;
        let faces = verts[0];

        //Top and bottom faces
        minX = 0;
        minZ = 2;
        maxX = 6;
        maxZ = 8;
        if (top) {
            faces = verts[1]
        }
        if (p.direction.y) {
            for (let face of faces) {
                m = (y + face[1] - p.y) / p.direction.y;
                ix = m * p.direction.x + p.x;
                iz = m * p.direction.z + p.z;
                if (m > 0 && m < cd && ix >= x + face[minX] && ix <= x + face[maxX] && iz >= z + face[minZ] && iz <= z + face[maxZ]) {
                    cd = m; //Ray crosses bottom face
                    cf = top ? "top" : "bottom";
                }
            }
        }

        //West and East faces
        if (east) {
            faces = verts[4];
            minY = 10;
            minZ = 11;
            maxY = 4;
            maxZ = 5;
        } else {
            faces = verts[5];
            minY = 7;
            minZ = 8;
            maxY = 1;
            maxZ = 2;
        }
        if (p.direction.x) {
            for (let face of faces) {
                m = (x + face[0] - p.x) / p.direction.x;
                iy = m * p.direction.y + p.y;
                iz = m * p.direction.z + p.z;
                if (m > 0 && m < cd && iy >= y + face[minY] && iy <= y + face[maxY] && iz >= z + face[minZ] && iz <= z + face[maxZ]) {
                    cd = m;
                    cf = east ? "east" : "west";
                }
            }
        }

        //South and North faces
        if (north) {
            faces = verts[2];
            minX = 6;
            minY = 7;
            maxX = 0;
            maxY = 1;
        } else {
            faces = verts[3];
            minX = 9;
            minY = 10;
            maxX = 3;
            maxY = 4;
        }
        if (p.direction.z) {
            for (let face of faces) {
                m = (z + face[2] - p.z) / p.direction.z;
                ix = m * p.direction.x + p.x;
                iy = m * p.direction.y + p.y;
                if (m > 0 && m < cd && ix >= x + face[minX] && ix <= x + face[maxX] && iy >= y + face[minY] && iy <= y + face[maxY]) {
                    cd = m;
                    cf = north ? "north" : "south";
                }
            }
        }
        return [ cd, cf ];
    }
    function runRayTrace(x, y, z) {
        let block = world.getBlock(x, y, z);
        if (block) {
            let slab = (block & 0x80) >> 7;
            let rt = rayTrace(x, y, z, slab ? shapes.slab : shapes.cube);

            if (rt[1] && rt[0] < hitBox.closest) {
                hitBox.closest = rt[0];
                hitBox.face = rt[1];
                hitBox.pos = [ x, y, z ];
                hitBox.shape = slab ? "slab" : "cube";
            }
        }
    }
    function lookingAt() {
        // Checks blocks in front of the player to see which one they're looking at
        hitBox.pos = null;
        hitBox.closest = 1e9;

        if (p.spectator) {
            return;
        }
        let blockState = world.getBlock(p2.x, p2.y, p2.z);
        if (blockState) {
            hitBox.pos = [ p2.x, p2.y, p2.z ];
            hitBox.closest = 0;
            hitBox.shape = (blockState & 0x80) ? "slab" : "cube";
            return;
        }

        let pd = p.direction;

        // Target block
        let tx = Math.round(pd.x * reach + p.x);
        let ty = Math.round(pd.y * reach + p.y);
        let tz = Math.round(pd.z * reach + p.z);

        let minX = p2.x;
        let maxX = 0;
        let minY = p2.y;
        let maxY = 0;
        let minZ = p2.z;
        let maxZ = 0;

        for (let i = 0; i < reach + 1; i++) {
            if (i > reach) {
                i = reach;
            }
            maxX = Math.round(p.x + pd.x * i);
            maxY = Math.round(p.y + pd.y * i);
            maxZ = Math.round(p.z + pd.z * i);
            if (maxX === minX && maxY === minY && maxZ === minZ) {
                continue;
            }
            if (minX !== maxX) {
                if (minY !== maxY) {
                    if (minZ !== maxZ) {
                        runRayTrace(maxX, maxY, maxZ);
                    }
                    runRayTrace(maxX, maxY, minZ);
                }
                if (minZ !== maxZ) {
                    runRayTrace(maxX, minY, maxZ);
                }
                runRayTrace(maxX, minY, minZ);
            }
            if (minY !== maxY) {
                if (minZ !== maxZ) {
                    runRayTrace(minX, maxY, maxZ);
                }
                runRayTrace(minX, maxY, minZ);
            }
            if (minZ !== maxZ) {
                runRayTrace(minX, minY, maxZ);
            }
            if (hitBox.pos) {
                return; //The ray has collided; it can't possibly find a closer collision now
            }
            minZ = maxZ;
            minY = maxY;
            minX = maxX;
        }
    }
    let inBox = function(x, y, z, w, h, d) {
        let iy = y - h/2 - p.topH;
        let ih = h + p.bottomH + p.topH;
        let ix = x - w/2 - p.w;
        let iw = w + p.w*2;
        let iz = z - d/2 - p.w;
        let id = d + p.w*2;
        return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id;
    };
    let onBox = function(x, y, z, w, h, d) {
        let iy = roundBits(y - h/2 - p.topH);
        let ih = roundBits(h + p.bottomH + p.topH);
        let ix = roundBits(x - w/2 - p.w);
        let iw = roundBits(w + p.w*2);
        let iz = roundBits(z - d/2 - p.w);
        let id = roundBits(d + p.w*2);
        return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y <= iy + ih && p.z < iz + id;
    };
    function collided(x, y, z, vx, vy, vz, block) {
        if(p.spectator) {
            return false;
        }
        let verts = shapes[(block & 0x80) ? "slab" : "cube"].verts;
        let px = roundBits(p.x - p.w - x);
        let py = roundBits(p.y - p.bottomH - y);
        let pz = roundBits(p.z - p.w - z);
        let pxx = roundBits(p.x + p.w - x);
        let pyy = roundBits(p.y + p.topH - y);
        let pzz = roundBits(p.z + p.w - z);

        //Top and bottom faces
        let minX = 0;
        let minZ = 2;
        let maxX = 6;
        let maxZ = 8;
        let faces = verts[0];
        if (!vx && !vz) {
            if (vy <= 0) {
                faces = verts[1];
            }
            for (let face of faces) {
                if (face[1] > py && face[1] < pyy && face[minX] < pxx && face[maxX] > px && face[minZ] < pzz && face[maxZ] > pz) {
                    if (vy <= 0) {
                        p.onGround = true;
                        p.y = Math.round((face[1] + y + p.bottomH) * 10000) / 10000;
                        return false;
                    } else {
                        return true;
                    }
                }
            }
            return false;
        }

        //West and East faces
        let minY = 0;
        let maxY = 0;
        if (vx < 0) {
            faces = verts[4];
            minY = 10;
            minZ = 11;
            maxY = 4;
            maxZ = 5;
        } else if (vx > 0) {
            faces = verts[5];
            minY = 7;
            minZ = 8;
            maxY = 1;
            maxZ = 2;
        }
        if (vx) {
            for (let face of faces) {
                if (face[0] > px && face[0] < pxx && face[minY] < pyy && face[maxY] > py && face[minZ] < pzz && face[maxZ] > pz) {
                    if (face[maxY] - py > 0.5) {
                        p.canStep = false;
                    }
                    return true;
                }
            }
            return false;
        }

        //South and North faces
        if (vz < 0) {
            faces = verts[2];
            minX = 6;
            minY = 7;
            maxX = 0;
            maxY = 1;
        } else if (vz > 0) {
            faces = verts[3];
            minX = 9;
            minY = 10;
            maxX = 3;
            maxY = 4;
        }
        if (vz) {
            for (let face of faces) {
                if (face[2] > pz && face[2] < pzz && face[minY] < pyy && face[maxY] > py && face[minX] < pxx && face[maxX] > px) {
                    if (face[maxY] - py > 0.5) {
                        p.canStep = false;
                    }
                    return true;
                }
            }
            return false;
        }
    };
    let contacts = {
        array: [],
        size: 0,
        add: function(x, y, z, block) {
            if (this.size === this.array.length) {
                this.array.push([ x, y, z, block ]);
            } else {
                this.array[this.size][0] = x;
                this.array[this.size][1] = y;
                this.array[this.size][2] = z;
                this.array[this.size][3] = block;
            }
            this.size++;
        },
        clear: function() {
            this.size = 0;
        },
    };
    let resolveContactsAndUpdatePosition = function() {
        let pminX = p2.x - 1;
        let pmaxX = p2.x + 1;
        let pminY = p2.y - 2;
        let pmaxY = p2.y + 1;
        let pminZ = p2.z - 1;
        let pmaxZ = p2.z + 1;
        let block = null;
        let vel = p.velocity;

        for (let x = pminX; x <= pmaxX; x++) {
            for (let y = pminY; y <= pmaxY; y++) {
                for (let z = pminZ; z <= pmaxZ; z++) {
                    let block = world.getBlock(x, y, z)
                    if (block) {
                        contacts.add(x, y, z, block);
                    }
                }
            }
        }

        let dt = (win.performance.now() - p.lastUpdate) / 33;
        dt = dt > 2 ? 2 : dt;

        p.previousX = p.x;
        p.previousY = p.y;
        p.previousZ = p.z;

        //Check collisions in the Y direction
        p.onGround = false;
        p.canStep = false;
        p.y += vel.y * dt;
        for (let i = 0; i < contacts.size; i++) {
            block = contacts.array[i];
            if (collided(block[0], block[1], block[2], 0, vel.y, 0, block[3])) {
                p.y = p.previousY;
                vel.y = 0;
                break;
            }
        }
        if (p.y === p.previousY) {
            p.canStep = true;
        }

        var sneakLock = false, sneakSafe = false;
        if (p.sneaking) {
            for (let i = 0; i < contacts.size; i++) {
                block = contacts.array[i];
                if (onBox(block[0], block[1], block[2], 1, 1, 1)) {
                    sneakLock = true;
                    break;
                }
            }
        }

        //Check collisions in the X direction
        p.x += vel.x * dt;
        for (let i = 0; i < contacts.size; i++) {
            block = contacts.array[i];
            if (collided(block[0], block[1], block[2], vel.x, 0, 0, block[3])) {
                if (p.canStep && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
                    collided(block[0], block[1], block[2], 0, vel.y, 0, block[3]);
                    break;
                }
                p.x = p.previousX;
                vel.x = 0;
                break;
            }
            if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
                sneakSafe = true;
            }
        }

        if (sneakLock && !sneakSafe) {
            p.x = p.previousX;
            vel.x = 0;
        }
        sneakSafe = false;

        //Check collisions in the Z direction
        p.z += vel.z * dt;
        for (let i = 0; i < contacts.size; i++) {
            block = contacts.array[i];
            if (collided(block[0], block[1], block[2], 0, 0, vel.z, block[3])) {
                if (p.canStep && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
                    collided(block[0], block[1], block[2], 0, vel.y, 0, block[3]);
                    break;
                }
                p.z = p.previousZ;
                vel.z = 0;
                break;
            }
            if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
                sneakSafe = true;
            }
        }

        if (sneakLock && !sneakSafe) {
            p.z = p.previousZ;
            vel.z = 0;
        }

        if (!p.flying) {
            let drag = p.onGround ? 0.5 : 0.85;
            p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt;
            p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt;
        } else {
            let drag = 0.9;
            p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt;
            p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt;
            p.velocity.y += (p.velocity.y * 0.8 - p.velocity.y) * dt;
            if (p.onGround && !p.spectator) {
                p.flying = false;
            }
        }

        p.lastUpdate = win.performance.now();
        contacts.clear();
        lookingAt();
    };
    let runGravity = function() {
        if (p.flying) {
            return;
        }
        let dt = (win.performance.now() - p.lastUpdate) / 33;
        dt = dt > 2 ? 2 : dt;
        if(p.onGround) {
            if(Key[" "]) {
                p.velocity.y = p.jumpSpeed;
                p.onGround = false;
            } else {
                p.velocity.y = 0;
            }
        } else {
            p.velocity.y += p.gravityStength * dt;
            if(p.velocity.y < -p.maxYVelocity) {
                p.velocity.y = -p.maxYVelocity;
            }
        }
    };

    function box2(sides, tex) {
        if (blockFill) {
            let i = 0;
            for (let side in Block) {
                if (sides & Block[side]) {
                    vertexAttribPointer("aVertex", programObject3D, "aVertex", 3, sideEdgeBuffers[Sides[side]]);
                    vertexAttribPointer("aTexture", programObject3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]]);
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0);
                }
                i++;
            }
        }
        if (blockOutlines) {
            vertexAttribPointer("aVertex", programObject3D, "aVertex", 3, shapes[hitBox.shape].buffer);
            vertexAttribPointer("aTexture", programObject3D, "aTexture", 2, texCoordsBuffers[textureMap.hitbox]);
            for (let i = 0; i < shapes[hitBox.shape].size; i++) {
                gl.drawArrays(gl.LINE_LOOP, i * 4, 4);
            }
        }
    }
    function block2(x, y, z, t) {
        copyArr(modelView, matrix);
        trans(modelView, x, y, z);
        matMult();
        trans(modelView, -x, -y, -z);
        transpose(matrix);
        uniformMatrix("view3d", programObject3D, "uView", false, matrix);
        box2(0xff, blockData[t].textures);
    }

    let changeWorldBlock = function(t) {
        let pos = hitBox.pos;
        if(pos && pos[1] > 0 && pos[1] < maxHeight) {
            world.setBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], t);
            if (t) {
                p.lastPlace = Date.now();
            } else {
                p.lastBreak = Date.now();
            }
        }
    };
    let newWorldBlock = function() {
        if(!hitBox.pos || !holding) {
            return;
        }
        let pos = hitBox.pos, x= pos[0], y = pos[1], z = pos[2];
        switch(hitBox.face) {
            case "top":
                y += 1;
                break;
            case "bottom":
                y -= 1;
                break;
            case "south":
                z -= 1;
                break;
            case "north":
                z += 1;
                break;
            case "west":
                x -= 1;
                break;
            case "east":
                x += 1;
                break;
        }
        if (!inBox(x, y, z, 1, 1, 1) && !world.getBlock(x, y, z)) {
            pos[0] = x;
            pos[1] = y;
            pos[2] = z;
            changeWorldBlock(holding | blockMode << 7);
        }
    };

    let sphere;
    (function() {
        let blocks = [];
        let radius = 3.5;
        let radsq = radius * radius;
        for (let i = -radius; i <= radius; i++) {
            for (let j = -radius; j <= radius; j++) {
                for (let k = -radius; k <= radius; k++) {
                    if (i*i + j*j + k*k < radsq) {
                        blocks.push(i|0, j|0, k|0);
                    }
                }
            }
        }
        sphere = new Int8Array(blocks);
    })();
    generator.caveSize = 0.0055;
    function isCave(x, y, z) {
        let smooth = 0.02;
        let cave1 = Math.abs(0.5 - caveNoise(x * smooth, y * smooth, z * smooth)) < generator.caveSize;
        let cave2 = Math.abs(0.5 - caveNoise(y * smooth, z * smooth, x * smooth)) < generator.caveSize;
        return (cave1 && cave2);
    }
    function carveSphere(x, y, z) {
        if (y > 3) {
            for (let i = 0; i < sphere.length; i += 3) {
                world.setBlock(x + sphere[i], y + sphere[i + 1], z + sphere[i + 2], blockIds.air, true);
            }
        }
    }

    let renderedChunks = 0;
    function getBlock(x, y, z, blocks) {
        return blocks[((x >> 4) + 1) * 9 + ((y >> 4) + 1) * 3 + (z >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)] & 127;
    }
    function getBlock2(x, y, z, blocks) {
        return blocks[((x >> 4) + 1) * 9 + ((y >> 4) + 1) * 3 + (z >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)] & 0xff;
    }
    function hideFace(x, y, z, blocks, type, func) {
        let block = func.call(world, x, y, z, blocks);
        let data = blockData[block & 127]
        if (!block || block !== type && data.transparent || data.transparent && data.shadow || (block & 128)) {
            return 1;
        }
        return 0;
    }
    let getShadows = {
        shade: [ 1, 0.85, 0.7, 0.6, 0.3 ],
        top: function(x, y, z, block) {
            let blocks = [
                blockData[getBlock(x-1, y-1, z-1, block)].shadow,
                blockData[getBlock(x, y-1, z-1, block)].shadow,
                blockData[getBlock(x+1, y-1, z-1, block)].shadow,
                blockData[getBlock(x-1, y-1, z, block)].shadow,
                blockData[getBlock(x, y-1, z, block)].shadow,
                blockData[getBlock(x+1, y-1, z, block)].shadow,
                blockData[getBlock(x-1, y-1, z+1, block)].shadow,
                blockData[getBlock(x, y-1, z+1, block)].shadow,
                blockData[getBlock(x+1, y-1, z+1, block)].shadow,
            ];
            return [
                this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8,
                this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8,
                this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8,
                this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8,
            ];
        },
        bottom: function(x, y, z, block) {
            let blocks = [
                blockData[getBlock(x-1, y+1, z-1, block)].shadow,
                blockData[getBlock(x, y+1, z-1, block)].shadow,
                blockData[getBlock(x+1, y+1, z-1, block)].shadow,
                blockData[getBlock(x-1, y+1, z, block)].shadow,
                blockData[getBlock(x, y+1, z, block)].shadow,
                blockData[getBlock(x+1, y+1, z, block)].shadow,
                blockData[getBlock(x-1, y+1, z+1, block)].shadow,
                blockData[getBlock(x, y+1, z+1, block)].shadow,
                blockData[getBlock(x+1, y+1, z+1, block)].shadow,
            ];
            return [
                this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]],
                this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
                this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
                this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]],
            ];
        },
        north: function(x, y, z, block) {
            let blocks = [
                blockData[getBlock(x-1, y-1, z+1, block)].shadow,
                blockData[getBlock(x, y-1, z+1, block)].shadow,
                blockData[getBlock(x+1, y-1, z+1, block)].shadow,
                blockData[getBlock(x-1, y, z+1, block)].shadow,
                blockData[getBlock(x, y, z+1, block)].shadow,
                blockData[getBlock(x+1, y, z+1, block)].shadow,
                blockData[getBlock(x-1, y+1, z+1, block)].shadow,
                blockData[getBlock(x, y+1, z+1, block)].shadow,
                blockData[getBlock(x+1, y+1, z+1, block)].shadow,
            ];
            return [
                this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
                this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
                this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]],
                this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]],
            ];
        },
        south: function(x, y, z, block) {
            let blocks = [
                blockData[getBlock(x-1, y-1, z-1, block)].shadow,
                blockData[getBlock(x-1, y, z-1, block)].shadow,
                blockData[getBlock(x-1, y+1, z-1, block)].shadow,
                blockData[getBlock(x, y-1, z-1, block)].shadow,
                blockData[getBlock(x, y, z-1, block)].shadow,
                blockData[getBlock(x, y+1, z-1, block)].shadow,
                blockData[getBlock(x+1, y-1, z-1, block)].shadow,
                blockData[getBlock(x+1, y, z-1, block)].shadow,
                blockData[getBlock(x+1, y+1, z-1, block)].shadow,
            ];
            return [
                this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]],
                this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
                this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
                this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]],
            ];
        },
        east: function(x, y, z, block) {
            let blocks = [
                blockData[getBlock(x+1, y-1, z-1, block)].shadow,
                blockData[getBlock(x+1, y, z-1, block)].shadow,
                blockData[getBlock(x+1, y+1, z-1, block)].shadow,
                blockData[getBlock(x+1, y-1, z, block)].shadow,
                blockData[getBlock(x+1, y, z, block)].shadow,
                blockData[getBlock(x+1, y+1, z, block)].shadow,
                blockData[getBlock(x+1, y-1, z+1, block)].shadow,
                blockData[getBlock(x+1, y, z+1, block)].shadow,
                blockData[getBlock(x+1, y+1, z+1, block)].shadow,
            ];
            return [
                this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8,
                this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8,
                this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8,
                this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8,
            ];
        },
        west: function(x, y, z, block) {
            let blocks = [
                blockData[getBlock(x-1, y-1, z-1, block)].shadow,
                blockData[getBlock(x-1, y, z-1, block)].shadow,
                blockData[getBlock(x-1, y+1, z-1, block)].shadow,
                blockData[getBlock(x-1, y-1, z, block)].shadow,
                blockData[getBlock(x-1, y, z, block)].shadow,
                blockData[getBlock(x-1, y+1, z, block)].shadow,
                blockData[getBlock(x-1, y-1, z+1, block)].shadow,
                blockData[getBlock(x-1, y, z+1, block)].shadow,
                blockData[getBlock(x-1, y+1, z+1, block)].shadow,
            ];
            return [
                this.shade[blocks[7] + blocks[8] + blocks[4] + blocks[5]]*0.8,
                this.shade[blocks[5] + blocks[4] + blocks[2] + blocks[1]]*0.8,
                this.shade[blocks[4] + blocks[3] + blocks[1] + blocks[0]]*0.8,
                this.shade[blocks[6] + blocks[7] + blocks[3] + blocks[4]]*0.8,
            ];
        },
    };

    /** Section Class **/
    //{
    function Section(x, y, z, size, chunk) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.size = size;
        this.arraySize = size * size * size;
        this.blocks = newInt32Array(this.arraySize);
        this.renderData = [];
        this.renderLength = 0;
        this.faces = 0;
        this.hasVisibleBlocks = false;
        this.chunk = chunk;
        this.edited = false;
        this.caves = false;
    }
    Section.prototype.getBlock = function(x, y, z) {
        let s = this.size;
        return this.blocks[x * s * s + y * s + z] & 0xff;
    };
    Section.prototype.setBlock = function(x, y, z, blockID, hidden) {
        let s = this.size;
        this.blocks[x * s * s + y * s + z] = !hidden << 31 | blockID;
    };
    Section.prototype.deleteBlock = function(x, y, z) {
        let s = this.size;
        let data = this.blocks[x * s * s + y * s + z];
        let index = this.renderData.indexOf(data);
        if (index >= 0 && index < this.renderLength) {
            this.renderData.splice(index, 1);
            this.renderLength--;
            this.hasVisibleBlocks = !!this.renderLength;
            if (!world.meshQueue.includes(this.chunk)) {
                world.meshQueue.push(this.chunk);
            }
        }
        this.blocks[x * s * s + y * s + z] = blockIds.air;
    };
    Section.prototype.optimize = function(world) {
        let visible = false;
        let pos = 0;
        let xx = this.x;
        let yy = this.y;
        let zz = this.z;
        let blockData = 0;
        let blockType = 0;
        let index = 0;
        let s = this.size;
        let blocks = this.blocks;
        this.hasVisibleBlocks = false;
        this.renderLength = 0;
        let localBlocks = world.getAdjacentSubchunks(xx, yy, zz);

        //Check all the blocks in the subchunk to see if they're visible.
        for (let i = 0; i < s; i++) {
            for (let j = 0; j < s; j++) {
                for (let k = 0; k < s; k++, index++) {
                    blockData = blocks[index];
                    if (blockData >= 0) {
                        continue;
                    }
                    blockType = blockData & 0xff;
                    // x = i + xx;
                    // y = j + yy;
                    // z = k + zz;
                    visible = hideFace(i-1, j, k, localBlocks, blockType, getBlock2)
                    | hideFace(i+1, j, k, localBlocks, blockType, getBlock2) << 1
                    | hideFace(i, j-1, k, localBlocks, blockType, getBlock2) << 2
                    | hideFace(i, j+1, k, localBlocks, blockType, getBlock2) << 3
                    | hideFace(i, j, k-1, localBlocks, blockType, getBlock2) << 4
                    | hideFace(i, j, k+1, localBlocks, blockType, getBlock2) << 5;
                    if (visible) {
                        pos = (i | j << 4 | k << 8) << 16;
                        blockData = 1 << 31 | pos | visible << 8 | blockType;
                        this.renderData[this.renderLength++] = blockData;
                        blocks[index] = blockData;
                        this.hasVisibleBlocks = true;
                    } else {
                        blocks[index] = blockType;
                    }
                }
            }
        }
    };
    Section.prototype.updateBlock = function(x, y, z, world) {
        let i = x;
        let j = y;
        let k = z;
        let s = this.size;
        x += this.x;
        y += this.y;
        z += this.z;
        let blockData = this.blocks[i * s * s + j * s + k];
        let blockType = blockData & 0xff;
        let visible = blockType && hideFace(x-1, y, z, 0, blockType, world.getBlock)
        | hideFace(x+1, y, z, 0, blockType, world.getBlock) << 1
        | hideFace(x, y-1, z, 0, blockType, world.getBlock) << 2
        | hideFace(x, y+1, z, 0, blockType, world.getBlock) << 3
        | hideFace(x, y, z-1, 0, blockType, world.getBlock) << 4
        | hideFace(x, y, z+1, 0, blockType, world.getBlock) << 5;
        let pos = (i | j << 4 | k << 8) << 16;
        let index = blockData < 0 ? this.renderData.indexOf(blockData) : -1;

        if ((index < 0 || index >= this.renderLength) && !visible) {
            if (!world.meshQueue.includes(this.chunk)) {
                world.meshQueue.push(this.chunk);
            }
            return;
        }
        if (!visible) {
            this.renderData.splice(index, 1);
            this.blocks[i * s * s + j * s + k] = blockType; //Toggle invisible bit
            this.renderLength--;
            this.hasVisibleBlocks = !!this.renderLength;
            if (!world.meshQueue.includes(this.chunk)) {
                world.meshQueue.push(this.chunk);
            }
            this.chunk.minY = y < this.chunk.minY ? y : this.chunk.minY;
            this.chunk.maxY = y > this.chunk.maxY ? y : this.chunk.maxY;
            return;
        }
        if (visible && (index < 0 || index >= this.renderLength)) {
            index = this.renderLength++;
            this.hasVisibleBlocks = true;
        }
        this.chunk.minY = y < this.chunk.minY ? y : this.chunk.minY;
        this.chunk.maxY = y > this.chunk.maxY ? y : this.chunk.maxY;
        this.renderData[index] = 1 << 31 | pos | visible << 8 | blockData & 0xff;
        this.blocks[i * s * s + j * s + k] = this.renderData[index];
        if (!world.meshQueue.includes(this.chunk)) {
            world.meshQueue.push(this.chunk);
        }
    };
    Section.prototype.genMesh = function(barray, index) {
        if (!this.renderLength) {
            return index;
        }
        let length = this.renderLength;
        let rData = this.renderData;
        let x = 0, y = 0, z = 0, loc = 0, data = 0, sides = 0, tex = null, x2 = 0, y2 = 0, z2 = 0, verts = null, texVerts = null, texShapeVerts = null, tx = 0, ty = 0;
        let wx = this.x, wy = this.y, wz = this.z;
        let blocks = world.getAdjacentSubchunks(wx, wy, wz);

        let shadows = null;
        let blockSides = Object.keys(Block);
        let side = "";
        let shapeVerts = null;
        let shapeTexVerts = null;
        for (let i = 0; i < length; i++) {
            data = rData[i];
            tex = blockData[data & 127].textures;
            sides = data >> 8 & 0x3f;
            loc = data >> 16;
            x = loc & 15;
            y = loc >> 4 & 15;
            z = loc >> 8 & 15;

            x2 = x + this.x;
            y2 = y + this.y;
            z2 = z + this.z;

            if (data & 128) {
                shapeVerts = shapes.slab.verts;
                shapeTexVerts = shapes.slab.texVerts;
            } else {
                shapeVerts = shapes.cube.verts;
                shapeTexVerts = shapes.cube.texVerts;
            }

            let texNum = 0;
            for (let n = 0; n < 6; n++) {
                side = blockSides[n];
                if (sides & Block[side]) {
                    shadows = getShadows[side](x, y, z, blocks);
                    verts = shapeVerts[Sides[side]][0];
                    texVerts = textureCoords[textureMap[tex[texNum]]];
                    tx = texVerts[2];
                    ty = texVerts[3];
                    texShapeVerts = shapeTexVerts[n][0];

                    barray[index] = verts[0] + x2;
                    barray[index+1] = verts[1] + y2;
                    barray[index+2] = verts[2] + z2;
                    barray[index+3] = tx + texShapeVerts[0];
                    barray[index+4] = ty + texShapeVerts[1];
                    barray[index+5] = shadows[0];

                    barray[index+6] = verts[3] + x2;
                    barray[index+7] = verts[4] + y2;
                    barray[index+8] = verts[5] + z2;
                    barray[index+9] = tx + texShapeVerts[2];
                    barray[index+10] = ty + texShapeVerts[3];
                    barray[index+11] = shadows[1];

                    barray[index+12] = verts[6] + x2;
                    barray[index+13] = verts[7] + y2;
                    barray[index+14] = verts[8] + z2;
                    barray[index+15] = tx + texShapeVerts[4];
                    barray[index+16] = ty + texShapeVerts[5];
                    barray[index+17] = shadows[2];

                    barray[index+18] = verts[9] + x2;
                    barray[index+19] = verts[10] + y2;
                    barray[index+20] = verts[11] + z2;
                    barray[index+21] = tx + texShapeVerts[6];
                    barray[index+22] = ty + texShapeVerts[7];
                    barray[index+23] = shadows[3];
                    index += 24;
                }
                texNum++;
            }
        }
        return index;
    };
    Section.prototype.carveCaves = function() {
        let wx = this.x + 16, wz = this.z + 16, wy = this.y + 16;
        for (let x = this.x, xx = 0; x < wx; x++, xx++) {
            for (let z = this.z, zz = 0; z < wz; z++, zz++) {
                wy = this.chunk.tops[zz * 16 + xx];
                for (let y = this.y; y < wy; y++) {
                    if (isCave(x, y, z)) {
                        carveSphere(x, y, z);
                    }
                }
            }
        }
        this.caves = true;
    }
    Section.prototype.tick = function() {
        for (let i = 0; i < 3; i++) {
            let rnd = Math.random() * this.blocks.length | 0;
            if ((this.blocks[rnd] & 255) === blockIds.grass) {
                // Spread grass

                let x = (rnd >> 8) + this.x;
                let y = (rnd >> 4 & 15) + this.y;
                let z = (rnd & 15) + this.z;
                if (!blockData[world.getBlock(x, y + 1, z) & 127].transparent) {
                    world.setBlock(x, y, z, blockIds.air, false);
                    world.setBlock(x, y, z, blockIds.dirt, false);
                    return;
                }

                let rnd2 = Math.random() * 27 | 0;
                let x2 = rnd2 % 3 - 1;
                rnd2 = (rnd2 - x2 - 1) / 3;
                let y2 = rnd2 % 3 - 1;
                rnd2 = (rnd2 - y2 - 1) / 3;
                z += rnd2 - 1;
                x += x2;
                y += y2;

                if (world.getBlock(x, y, z) === blockIds.dirt && world.getBlock(x, y + 1, z) === blockIds.air) {
                    world.setBlock(x, y, z, blockIds.air, false);
                    world.setBlock(x, y, z, blockIds.grass, false);
                }
            }
        }
    };
    //}
    function newSection(x, y, z, size, chunk) {
        let section = Object.create(Section.prototype);
        Section.apply(section, [ x, y, z, size, chunk ]);
        return section;
    }
    let emptySection = newSection(0, 0, 0, 16);
    let fullSection = newSection(0, 0, 0, 16);
    fullSection.blocks.fill(blockIds.bedrock);

    /** Chunk Class **/
    //{
    function Chunk(x, z) {
        this.x = x;
        this.z = z;
        this.maxY = 0;
        this.minY = 255;
        this.sections = [];
        this.cleanSections = [];
        this.tops = new Uint8Array(16 * 16); // Store the heighest block at every (x,z) coordinate
        this.optimized = false;
        this.generated = false; //Terrain
        this.populated = superflat; //Trees
        this.lazy = false;
        this.edited = false;
        this.caves = superflat;
    }
    Chunk.prototype.getBlock = function(x, y, z) {
        let s = y >> 4;
        return this.sections.length > s ? this.sections[s].getBlock(x, y & 15, z) : 0;
    };
    Chunk.prototype.setBlock = function(x, y, z, blockID, hidden, user) {
        if (!this.sections[y >> 4]) {
            do {
                this.sections.push(newSection(this.x, this.sections.length * 16, this.z, 16, this));
            } while (!this.sections[y >> 4]);
        }
        if (user && !this.sections[y >> 4].edited) {
            this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice();
            this.sections[y >> 4].edited = true;
            this.edited = true;
        }
        this.sections[y >> 4].setBlock(x, y & 15, z, blockID, hidden);
    };
    Chunk.prototype.optimize = function(world) {
        for (let i = 0; i < this.sections.length; i++) {
            this.sections[i].optimize(world);
        }
        if (!world.meshQueue.includes(this)) {
            world.meshQueue.push(this);
        }
        this.optimized = true;
    };
    Chunk.prototype.render = function() {
        if (!this.buffer) {
            return;
        }
        if (chunkVisible(this.x, this.minY, this.z, this.maxY)) {
            renderedChunks++;
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.vertexAttribPointer(glCache.locations.aVertex, 3, gl.FLOAT, false, 24, 0);
            gl.vertexAttribPointer(glCache.locations.aTexture, 2, gl.FLOAT, false, 24, 12);
            gl.vertexAttribPointer(glCache.locations.aShadow, 1, gl.FLOAT, false, 24, 20);
            gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0);
        }
    };
    Chunk.prototype.updateBlock = function(x, y, z, world, lazy) {
        if (this.buffer) {
            this.lazy = lazy;
            if (this.sections.length > y >> 4) {
                this.sections[y >> 4].updateBlock(x, y & 15, z, world);
            }
        }
    };
    Chunk.prototype.deleteBlock = function(x, y, z, user) {
        if (!this.sections[y >> 4]) {
            return;
        }
        if (user && !this.sections[y >> 4].edited) {
            this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice();
            this.sections[y >> 4].edited = true;
            this.edited = true;
        }
        this.sections[y >> 4].deleteBlock(x, y & 15, z);
        this.minY = y < this.minY ? y : this.minY;
        this.maxY = y > this.maxY ? y : this.maxY;
        // if (y === this.tops[z * 16 + x]) {
        //     while(--y && !this.getBlock(x, y, z)) {}
        //     this.tops[z * 16 + x] = y;
        // }
    };
    Chunk.prototype.carveCaves = function() {
        for (let i = 0; i < this.sections.length; i++) {
            if (!this.sections[i].caves) {
                this.sections[i].carveCaves();
                if (i + 1 >= this.sections.length) {
                    this.caves = true;
                }
                return;
            }
        }
    };
    Chunk.prototype.populate = function() {
        randomSeed(hash(this.x, this.z) * 210000000);
        let wx = 0, wz = 0, ground = 0, top = 0, rand = 0, place = false;

        for (let i = 0; i < 16; i++) {
            for (let k = 0; k < 16; k++) {
                wx = this.x + i;
                wz = this.z + k;
                ground = this.tops[k * 16 + i];
                if (random() < 0.005 && this.getBlock(i, ground, k)) {

                    top = ground + Math.floor(4.5 + random(2.5));
                    rand = Math.floor(random(4096));
                    let tree = random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog;

                    //Center
                    for (let j = ground + 1; j <= top; j++) {
                        this.setBlock(i, j, k, tree);
                    }
                    this.setBlock(i, top + 1, k, blockIds.leaves);
                    this.setBlock(i, ground, k, blockIds.dirt);

                    //Bottom leaves
                    for (let x = -2; x <= 2; x++) {
                        for (let z = -2; z <= 2; z++) {
                            if (x || z) {
                                if ((x * z & 7) === 4) {
                                    place = rand & 1;
                                    rand >>>= 1;
                                    if (place) {
                                        world.spawnBlock(wx + x, top - 2, wz + z, blockIds.leaves);
                                    }
                                } else {
                                    world.spawnBlock(wx + x, top - 2, wz + z, blockIds.leaves);
                                }
                            }
                        }
                    }

                    //2nd layer leaves
                    for (let x = -2; x <= 2; x++) {
                        for (let z = -2; z <= 2; z++) {
                            if (x || z) {
                                if ((x * z & 7) === 4) {
                                    place = rand & 1;
                                    rand >>>= 1;
                                    if (place) {
                                        world.spawnBlock(wx + x, top - 1, wz + z, blockIds.leaves);
                                    }
                                } else {
                                    world.spawnBlock(wx + x, top - 1, wz + z, blockIds.leaves);
                                }
                            }
                        }
                    }

                    //3rd layer leaves
                    for (let x = -1; x <= 1; x++) {
                        for (let z = -1; z <= 1; z++) {
                            if (x || z) {
                                if (x & z) {
                                    place = rand & 1;
                                    rand >>>= 1;
                                    if (place) {
                                        world.spawnBlock(wx + x, top, wz + z, blockIds.leaves);
                                    }
                                } else {
                                    world.spawnBlock(wx + x, top, wz + z, blockIds.leaves);
                                }
                            }
                        }
                    }

                    //Top leaves
                    world.spawnBlock(wx + 1, top + 1, wz, blockIds.leaves);
                    world.spawnBlock(wx, top + 1, wz - 1, blockIds.leaves);
                    world.spawnBlock(wx, top + 1, wz + 1, blockIds.leaves);
                    world.spawnBlock(wx - 1, top + 1, wz, blockIds.leaves);
                }

                // Blocks of each per chunk in GirlCraft
                // Coal: 185.5
                // Iron: 111.5
                // Gold: 10.4
                // Redstone: 29.1
                // Diamond: 3.7
                // Lapis: 4.1
                ground -= 4;

                if (random() < 3.7 / 256) {
                    let y = random() * 16 | 0 + 1;
                    y = y < ground ? y : ground;
                    if (this.getBlock(i, y, k)) {
                        this.setBlock(i, y < ground ? y : ground, k, blockIds.diamondOre);
                    }
                }

                if (random() < 111.5 / 256) {
                    let y = random() * 64 | 0 + 1;
                    y = y < ground ? y : ground;
                    if (this.getBlock(i, y, k)) {
                        this.setBlock(i, y < ground ? y : ground, k, blockIds.ironOre);
                    }
                }

                if (random() < 185.5 / 256) {
                    let y = random() * ground | 0 + 1;
                    y = y < ground ? y : ground;
                    if (this.getBlock(i, y, k)) {
                        this.setBlock(i, y < ground ? y : ground, k, blockIds.coalOre);
                    }
                }

                if (random() < 10.4 / 256) {
                    let y = random() * 32 | 0 + 1;
                    y = y < ground ? y : ground;
                    if (this.getBlock(i, y, k)) {
                        this.setBlock(i, y < ground ? y : ground, k, blockIds.goldOre);
                    }
                }

                if (random() < 29.1 / 256) {
                    let y = random() * 16 | 0 + 1;
                    y = y < ground ? y : ground;
                    if (this.getBlock(i, y, k)) {
                        this.setBlock(i, y < ground ? y : ground, k, blockIds.redstoneOre);
                    }
                }

                if (random() < 4.1 / 256) {
                    let y = random() * 32 | 0 + 1;
                    y = y < ground ? y : ground;
                    if (this.getBlock(i, y, k)) {
                        this.setBlock(i, y < ground ? y : ground, k, blockIds.lapisOre);
                    }
                }
            }
        }

        this.populated = true;
    };
    Chunk.prototype.genMesh = function() {
        let start = win.performance.now();
        let barray = bigArray;
        let index = 0;
        let g = gl;
        for (let i = 0; i < this.sections.length; i++) {
            index = this.sections[i].genMesh(barray, index);
        }
        let arrayDone = win.performance.now();

        if (!this.buffer) {
            this.buffer = g.createBuffer();
        }
        let data = barray.slice(0, index);
        let maxY = 0;
        let minY = 255;
        let y = 0;
        for (let i = 1; i < data.length; i += 6) {
            y = data[i]
            maxY = Math.max(maxY, y);
            minY = Math.min(minY, y);
        }
        this.maxY = maxY;
        this.minY = minY;
        this.faces = data.length / 24;
        g.bindBuffer(g.ARRAY_BUFFER, this.buffer);
        g.bufferData(g.ARRAY_BUFFER, data, g.DYNAMIC_DRAW);
        this.lazy = false;
    };
    Chunk.prototype.tick = function() {
        if (this.edited) {
            for (let i = 0; i < this.sections.length; i++) {
                if (this.sections[i].edited) {
                    this.sections[i].tick();
                }
            }
        }
    };
    Chunk.prototype.load = function() {
        let chunkX = this.x >> 4;
        let chunkZ = this.z >> 4;
        let load = null;
        
        for (let i = 0; i < world.loadFrom.length; i++) {
            load = world.loadFrom[i];
            if (load.x === chunkX && load.z === chunkZ) {
                let y = load.y * 16;
                for (let j in load.blocks) {
                    world.setBlock((j >> 8 & 15) + this.x, (j >> 4 & 15) + y, (j & 15) + this.z, load.blocks[j]);
                }
                world.loadFrom.splice(i--, 1);
            }
        }
    }
    //}
    function newChunk(x, z) {
        let chunk = Object.create(Chunk.prototype);
        Chunk.call(chunk, x, z);
        return chunk;
    }

    let analytics = {
        totalTickTime: 0,
        worstFrameTime: 0,
        totalRenderTime: 0,
        totalFrameTime: 0,
        lastUpdate: 0,
        frames: 1,
        displayedTickTime: "0",
        displayedRenderTime: "0",
        displayedFrameTime: "0",
        displayedwFrameTime: 0,
        fps: 0,
    };
    function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
        let dx1 = p.x - c1.x - 8;
        let dy1 = p.z - c1.z - 8;
        let dx2 = p.x - c2.x - 8;
        let dy2 = p.z - c2.z - 8;
        return dx1 * dx1 + dy1 * dy1 - (dx2 * dx2 + dy2 * dy2);
    }
    function fillReqs(x, z) {
        // Chunks must all be loaded first.
        var done = true;
        for (let i = x - 2; i <= x + 2; i++) {
            for (let j = z - 2; j <= z + 2; j++) {
                let chunk = world.loaded[(i + world.offsetX) * world.lwidth + j + world.offsetZ]
                if (!chunk.generated) {
                    world.generateQueue.push(chunk);
                    done = false;
                }
                if (!chunk.populated && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
                    world.populateQueue.push(chunk);
                    done = false;
                }
            }
        }
        return done;
    }
    function maxDist(x, z, x2, z2) {
        let ax = Math.abs(x2 - x);
        let az = Math.abs(z2 - z);
        return Math.max(ax, az);
    }
    function renderFilter(chunk) {
        return maxDist(chunk.x >> 4, chunk.z >> 4, p.cx, p.cz) <= renderDistance;
    }

    function debug(message) {
        let ellapsed = performance.now() - debug.start;
        if (ellapsed > 30) {
            console.log(message, ellapsed.toFixed(2), "milliseconds");
        }
    }
    /** World Class **/
    //{
    let genChunk = function(chunk) {
        let x = chunk.x >> 4;
        let z = chunk.z >> 4;
        let trueX = chunk.x;
        let trueZ = chunk.z;

        if (chunk.generated) {
            return false;
        }
        let hide = !loadString;
        let smoothness = generator.smooth;
        let hilliness = generator.height;
        let gen = 0;
        for (let i = 0; i < 16; i++) {
            for (let k = 0; k < 16; k++) {
                gen = superflat ? 4 : Math.round(noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness) + generator.extra;
                chunk.tops[k * 16 + i] = gen;

                chunk.setBlock(i, gen, k, blockIds.grass);
                chunk.setBlock(i, gen - 1, k, blockIds.dirt);
                chunk.setBlock(i, gen - 2, k, blockIds.dirt);
                chunk.setBlock(i, gen - 3, k, blockIds.dirt);
                for (let j = 1; j < gen - 3; j++) {
                    chunk.setBlock(i, j, k, blockIds.stone);
                }
                chunk.setBlock(i, 0, k, blockIds.bedrock);
            }
        }
        chunk.generated = true;
        generatedChunks++;
    };
    let getAdjacentSubchunks = function(x, y, z) {
        let minChunkX = x - 16 >> 4;
        let maxChunkX = x + 16 >> 4;
        let minChunkY = y - 16 >> 4;
        let maxChunkY = y + 16 >> 4;
        let minChunkZ = z - 16 >> 4;
        let maxChunkZ = z + 16 >> 4;
        let ret = [];
        for (x = minChunkX; x <= maxChunkX; x++) {
            for (let y = minChunkY; y <= maxChunkY; y++) {
                for (z = minChunkZ; z <= maxChunkZ; z++) {
                    if (y < 0) {
                        ret.push(fullSection.blocks);
                    } else if (this.chunks[x] && this.chunks[x][z]) {
                        ret.push((this.chunks[x][z].sections[y] || emptySection).blocks);
                    } else {
                        ret.push(emptySection.blocks);
                    }
                }
            }
        }
        return ret;
    };
    let updateBlock = function(x, y, z, lazy) {
        let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4];
        if (chunk && chunk.buffer) {
            chunk.updateBlock(x & 15, y, z & 15, this, lazy);
        }
    };
    let getWorldBlock = function(x, y, z) {
        if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
            return blockIds.air;
        }
        return this.chunks[x >> 4][z >> 4].getBlock(x & 15, y, z & 15);
    };
    let getLoadedBlock = function(x, y, z) {
        let X = (x >> 4) + this.offsetX;
        let Z = (z >> 4) + this.offsetZ;
        if (y > maxHeight) {
            return blockIds.air;
        } else if (y < 0) {
            return blockIds.bedrock;
        } else if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
            return this.getWorldBlock(x, y, z);
        }
        return this.loaded[X * this.lwidth + Z].getBlock(x & 15, y, z & 15);
    };
    let setBlock = function(x, y, z, blockID, lazy) {
        if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
            return;
        }
        let chunk = this.chunks[x >> 4][z >> 4];

        let xm = x & 15;
        let zm = z & 15;
        if (blockID) {
            chunk.setBlock(xm, y, zm, blockID, false, !lazy);
        } else {
            chunk.deleteBlock(xm, y, zm, !lazy);
        }



        //Update the 6 adjacent blocks and 1 changed block
        if (xm && xm !== 15 && zm && zm !== 15) {
            chunk.updateBlock(xm - 1, y, zm, this, lazy);
            chunk.updateBlock(xm + 1, y, zm, this, lazy);
            chunk.updateBlock(xm, y - 1, zm, this, lazy);
            chunk.updateBlock(xm, y + 1, zm, this, lazy);
            chunk.updateBlock(xm, y, zm - 1, this, lazy);
            chunk.updateBlock(xm, y, zm + 1, this, lazy);
        }
        else {
            this.updateBlock(x - 1, y, z, lazy);
            this.updateBlock(x + 1, y, z, lazy);
            this.updateBlock(x, y - 1, z, lazy);
            this.updateBlock(x, y + 1, z, lazy);
            this.updateBlock(x, y, z - 1, lazy);
            this.updateBlock(x, y, z + 1, lazy);
        }

        chunk.updateBlock(xm, y, zm, this, lazy);

        //Update the corner chunks so shadows in adjacent chunks update correctly
        if (xm | zm === 0) { this.updateBlock(x - 1, y, z - 1, lazy); }
        if (xm === 15 && zm === 0) { this.updateBlock(x + 1, y, z - 1, lazy); }
        if (xm === 0 && zm === 15) { this.updateBlock(x - 1, y, z + 1, lazy); }
        if (xm & zm === 15) { this.updateBlock(x + 1, y, z + 1, lazy); }
    };
    let spawnBlock = function(x, y, z, blockID) {
        //Sets a block anywhere without causing block updates around it. Only to be used in world gen.

        let chunkX = x >> 4;
        let chunkZ = z >> 4;
        if (!this.chunks[chunkX]) {
            this.chunks[chunkX] = [];
        }
        let chunk = this.chunks[chunkX][chunkZ];
        if (!chunk) {
            chunk = newChunk(chunkX * 16, chunkZ * 16);
            this.chunks[chunkX][chunkZ] = chunk;
        }
        if (chunk.buffer) {
            //Only used if spawning a block post-gen
            this.setBlock(x, y, z, blockID, true);
        } else if (!chunk.getBlock(x & 15, y, z & 15)) {
            chunk.setBlock(x & 15, y, z & 15, blockID, false);
        }
    };
    let tick = function() {
        let tickStart = win.performance.now();
        let maxChunkX = (p.x >> 4) + renderDistance;
        let maxChunkZ = (p.z >> 4) + renderDistance;
        let chunk = maxChunkX + "," + maxChunkZ;
        if (chunk !== this.lastChunk) {
            this.lastChunk = chunk;
            this.loadChunks();
            this.chunkGenQueue.sort(sortChunks);
        }

        if (Key.leftMouse && !Key.control && p.lastBreak < Date.now() - 250) {
            changeWorldBlock(0);
        }
        if ((Key.rightMouse || Key.leftMouse && Key.control) && p.lastPlace < Date.now() - 250) {
            newWorldBlock();
        }
        if (Key.leftMouse && p.autoBreak && !Key.control) {
            changeWorldBlock(0);
        }

        for (let i = 0; i < this.sortedChunks.length; i++) {
            this.sortedChunks[i].tick();
        }

        do {
            let doneWork = false;
            debug.start = performance.now();
            if (this.meshQueue.length) {
                // Update all chunk meshes.
                let len = this.meshQueue.length - 1;
                do {
                    this.meshQueue.pop().genMesh();
                } while(this.meshQueue.length);
                doneWork = true;
                debug("Meshes")
            }

            if (this.generateQueue.length && !doneWork) {
                let chunk = this.generateQueue.pop()
                this.genChunk(chunk);
                doneWork = true;
            }
            if (this.populateQueue.length && !doneWork) {
                let chunk = this.populateQueue[this.populateQueue.length - 1]
                if (!chunk.caves) {
                    chunk.carveCaves();
                    debug("Carve caves")
                } else if (!chunk.populated) {
                    chunk.populate();
                    this.populateQueue.pop();
                }
                doneWork = true;
            }

            if (this.chunkGenQueue.length && !doneWork) {
                let chunk = this.chunkGenQueue[0];
                if (!fillReqs(chunk.x >> 4, chunk.z >> 4)) {}
                else if (!chunk.optimized) {
                    chunk.load();
                    chunk.optimize(this);
                    debug("Optimize")
                } else if (!chunk.buffer) {
                    chunk.genMesh();
                    debug("Initial mesh")
                } else {
                    this.chunkGenQueue.shift();
                }
                doneWork = true;
            }
            if (!doneWork) {
                break;
            }
        } while(win.performance.now() - tickStart < 5);
    };
    let render = function() {
        initModelView(p.x, p.y, p.z, p.rx, p.ry);
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

        p2.x = Math.round(p.x);
        p2.y = Math.round(p.y);
        p2.z = Math.round(p.z);

        renderedChunks = 0;
        gl.enableVertexAttribArray(glCache.locations.aShadow);

        let c = this.sortedChunks;
        let lx = p.direction.x;
        let ly = p.direction.y;
        let lz = p.direction.z;
        let nlx = lx < 0 ? 0 : 16;
        let nly = ly < 0;
        let nlz = lz < 0 ? 0 : 16;
        let x = p.x;
        let y = p.y;
        let z = p.z;
        let dx = 0, dy = 0, dz = 0;
        let chunk = null;
        for (let i = 0, l = c.length; i < l; i++) {
            chunk = c[i];
            dx = chunk.x - x + nlx;
            dy = (nly ? chunk.minY : chunk.maxY) - y;
            dz = chunk.z - z + nlz;
            if (dx * lx + dy * ly + dz * lz > 0) {
                chunk.render();
            }
        }

        if(hitBox.pos) {
            blockOutlines = true;
            blockFill = false;
            block2(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0);
            blockOutlines = false;
            blockFill = true;
        }
    };
    let loadChunks = function() {
        renderDistance += 2;
        let cx = p.x >> 4;
        let cz = p.z >> 4;
        p.cx = cx;
        p.cz = cz;
        let minChunkX = cx - renderDistance;
        let maxChunkX = cx + renderDistance;
        let minChunkZ = cz - renderDistance;
        let maxChunkZ = cz + renderDistance;

        this.offsetX = -minChunkX;
        this.offsetZ = -minChunkZ;
        this.lwidth = renderDistance * 2 + 1;
        this.chunkGenQueue.length = 0;
        renderDistance -= 2;

        if (this.loaded.length > this.lwidth * this.lwidth) {
            this.loaded.length = this.lwidth * this.lwidth;
        }

        let i = 0;
        for (let x = minChunkX; x <= maxChunkX; x++) {
            for (let z = minChunkZ; z <= maxChunkZ; z++) {
                let chunk;
                if (!this.chunks[x]) {
                    this.chunks[x] = [];
                }
                if (!this.chunks[x][z]) {
                    chunk = newChunk(x * 16, z * 16);
                    if (maxDist(cx, cz, x, z) <= renderDistance) {
                        this.chunkGenQueue.push(chunk);
                    }
                    this.chunks[x][z] = chunk;
                }
                chunk = this.chunks[x][z];
                if (!chunk.buffer && !this.chunkGenQueue.includes(chunk) && maxDist(cx, cz, x, z) <= renderDistance) {
                    this.chunkGenQueue.push(chunk);
                }
                this.loaded[i++] = chunk;
            }
        }
        this.sortedChunks = this.loaded.filter(renderFilter);
        this.sortedChunks.sort(sortChunks);
    };
    function getSaveString() {
        let edited = [];
        for (let x in this.chunks) {
            for (let z in this.chunks[x]) {
                let chunk = this.chunks[x][z];
                if (chunk.edited) {
                    for (let y = 0; y < chunk.sections.length; y++) {
                        if (chunk.sections[y].edited) {
                            edited.push([ chunk.sections[y], chunk.cleanSections[y] ]);
                        }
                    }
                }
            }
        }

        let str = worldSeed.toString(36) + ";"
            + Math.round(p.x).toString(36) + "," + Math.round(p.y).toString(36) + "," + Math.round(p.z).toString(36) + ","
            + (p.rx * 100 | 0).toString(36) + "," + (p.ry * 100 | 0).toString(36) + ";"
            + edited.length.toString(36) + ";";
        for (let i = 0; i < edited.length; i++) {
            let sc = edited[i][0];
            str += (sc.x / 16).toString(36) + ",";
            str += (sc.y / 16).toString(36) + ",";
            str += (sc.z / 16).toString(36) + ",";
        }
        if (edited.length) str = str.substr(0, str.length - 1); //Remove trailing comma
        str += ";";

        for (let i = 0; i < edited.length; i++) {
            let real = edited[i][0];
            let blocks = real.blocks;
            let original = edited[i][1];
            let hasBlocks = false;
            for (let j = 0; j < original.length; j++) {
                if ((blocks[j] & 0xff) !== (original[j] & 0xff)) {
                    str += (j << 8 | blocks[j] & 0xff).toString(36) + ",";
                    hasBlocks = true;
                }
            }
            if (hasBlocks) str = str.substr(0, str.length - 1); //Remove trailing comma
            str += ";";
        }
        str = str.substr(0, str.length - 1);
        return str;
    }
    function loadSave(str) {
        let data = str.split(";");
        worldSeed = parseInt(data.shift(), 36);
        seedHash(worldSeed);
        caveNoise = openSimplexNoise(worldSeed);
        noiseSeed(worldSeed);
        let playerData = data.shift().split(",");
        p.x = parseInt(playerData[0], 36);
        p.y = parseInt(playerData[1], 36);
        p.z = parseInt(playerData[2], 36);
        p.rx = parseInt(playerData[3], 36) / 100;
        p.ry = parseInt(playerData[4], 36) / 100;
        let editCount = parseInt(data.shift(), 36);

        this.loadFrom = [];

        let coords = data.shift().split(",").map(function(n) {
            return parseInt(n, 36);
        });
        for (let j = 0; j < coords.length; j += 3) {
            this.loadFrom.push({
                x: coords[j],
                y: coords[j + 1],
                z: coords[j + 2],
                blocks: [],
            })
        }

        for (let i = 0; data.length > 0; i++) {
            let blocks = data.shift().split(",");
            for (let j = 0; j < blocks.length; j++) {
                let block = parseInt(blocks[j], 36);
                let index = block >> 8;
                let id = block & 0xff;
                this.loadFrom[i].blocks[index] = id;
            }
        }
    }
    //}
    function World() {
        generatedChunks = 0;

        p.y = superflat ? 6 : (Math.round(noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra);

        //Initialize the world's arrays
        return {
            chunks: [],
            loaded: [],
            sortedChunks: [],
            offsetX: 0,
            offsetZ: 0,
            lwidth: 0,
            chunkGenQueue: [],
            populateQueue: [],
            generateQueue: [],
            meshQueue: [],
            loadFrom: [],
            lastChunk: ",",
            genChunk: genChunk,
            getAdjacentSubchunks: getAdjacentSubchunks,
            updateBlock: updateBlock,
            getBlock: getLoadedBlock,
            getWorldBlock: getWorldBlock,
            setBlock: setBlock,
            spawnBlock: spawnBlock,
            tick: tick,
            render: render,
            loadChunks: loadChunks,
            getSaveString: getSaveString,
            loadSave: loadSave,
        };
    }

    let defineWorld = function() {
        let tickStart = win.performance.now();
        world.tick();
        analytics.totalTickTime += win.performance.now() - tickStart;
        let renderStart = win.performance.now();
        world.render();
        analytics.totalRenderTime += win.performance.now() - renderStart;
    };

    let controls = function() {
        move.x = 0;
        move.z = 0;
        let dt = (win.performance.now() - p.lastUpdate) / 33;
        dt = dt > 2 ? 2 : dt;
        if(Key.w) {
            move.z += p.speed;
        }
        if(Key.s) {
            move.z -= p.speed;
        }
        if(Key.a) {
            move.x += p.speed;
        }
        if(Key.d) {
            move.x -= p.speed;
        }
        if (p.flying) {
            if(Key[" "]) {
                p.velocity.y += 0.06 * dt;
            }
            if(Key.shift) {
                p.velocity.y -= 0.06 * dt;
            }
        }
        if(Key.arrowleft) {
            p.ry -= 0.1 * dt;
        }
        if(Key.arrowright) {
            p.ry += 0.1 * dt;
        }
        if(Key.arrowup) {
            p.rx += 0.1 * dt;
        }
        if(Key.arrowdown) {
            p.rx -= 0.1 * dt;
        }

        if (Key.q && !p.sneaking) {
            p.sprinting = true;
        }

        if(p.sprinting) {
            move.x *= p.sprintSpeed;
            move.z *= p.sprintSpeed;
        }
        if(p.flying) {
            move.x *= p.flySpeed;
            move.z *= p.flySpeed;
        }
        if (!move.x && !move.z) {
            p.sprinting = false;
        } else if(Math.abs(move.x) > 0 && Math.abs(move.z) > 0) {
            move.x *= move.ang;
            move.z *= move.ang;
        }
        //Update the velocity, rather than the position.
        let co = Math.cos(p.ry);
        let si = Math.sin(p.ry);
        let friction = p.onGround ? 1 : 0.3;
        p.velocity.x += (co * move.x - si * move.z) * friction * dt;
        p.velocity.z += (si * move.x + co * move.z) * friction * dt;

        while(p.ry > Math.PI*2) {
            p.ry -= Math.PI*2;
        }
        while(p.ry < 0) {
            p.ry += Math.PI*2;
        }
        if(p.rx > Math.PI / 2) {
            p.rx = Math.PI / 2;
        }
        if(p.rx < -Math.PI / 2) {
            p.rx = -Math.PI / 2;
        }

        p.direction.set(-si * Math.cos(p.rx), Math.sin(p.rx), co * Math.cos(p.rx));
        computeFrustum();
    };

    //Disable scroll
    (function() {
        let preventDefault = function(e) {
            e.preventDefault();
            if (e.deltaY > 0) {
                inventory.hotbarSlot++;
            } else if (e.deltaY < 0) {
                inventory.hotbarSlot--;
            }
            if (inventory.hotbarSlot > 8) {
                inventory.hotbarSlot = 0;
            } else if (inventory.hotbarSlot < 0) {
                inventory.hotbarSlot = 8;
            }

            updateHUD = true;
            holding = inventory.hotbar[inventory.hotbarSlot];
        };

        let keys = { 32: 1, 37: 1, 38: 1, 39: 1, 40: 1 };

        function preventDefaultForScrollKeys(e) {
            if (keys[e.keyCode]) {
                e.preventDefault();
                return false;
            }
        }

        // modern Chrome requires { passive: false } when adding event
        let supportsPassive = false;
        try {
            window.addEventListener("test", null, Object.defineProperty({}, 'passive', {
                get: function () {
                    supportsPassive = true;
                },
            }));
        } catch(e) {}

        let wheelOpt = supportsPassive ? { passive: false } : false;
        let wheelEvent = 'onwheel' in document.createElement('div') ? 'wheel' : 'mousewheel';

        // call this to Disable
        function disableScroll() {
            window.addEventListener('DOMMouseScroll', preventDefault, false); // older FF
            window.addEventListener(wheelEvent, preventDefault, wheelOpt); // modern desktop
            window.addEventListener('touchmove', preventDefault, wheelOpt); // mobile
            window.addEventListener('keydown', preventDefaultForScrollKeys, false);
        }

        disableScroll();
    })();

    // Mouse sensitivity variable, used for the settings buttons and in the "mmoved" function
    let mouseS = 300;

    let buttons = [];
    let button = function(x, y, w, h) {
        if(mouseX > x && mouseY > y && mouseX < x + w && mouseY < y + h) {
            return true;
        } else {
            return false;
        }
    };
    let addButton = function(x, y, w, h, text, callback, screen) {
        w = Math.max(w, 300);
        buttons.push({
            x: width / 2 - w / 2,
            y: y,
            w: w,
            h: h,
            text: text,
            callback: callback,
            screen: screen,
        });
    };
    let clickButton = function(button) {
        if (screen === button.screen && mouseX > button.x && mouseY > button.y && mouseX < button.x + button.w && mouseY < button.y + button.h) {
            button.callback();
        }
    };

    let drawButton = function(button) {
        if (screen === button.screen) {
            if (mouseX > button.x && mouseY > button.y && mouseX < button.x + button.w && mouseY < button.y + button.h) {
                strokeWeight(7);
            } else {
                strokeWeight(3);
            }
            ctx.strokeStyle = "rgb(30, 30, 30)";
            ctx.fillStyle = "rgb(120, 120, 120)";
            ctx.rect(button.x, button.y, button.w, button.h);
            ctx.stroke();
            ctx.fill();
            ctx.beginPath();
            ctx.textAlign = 'center';
            ctx.fillStyle = "rgb(80, 80, 80)";
            ctx.font = "35.5px VT323";
            ctx.fillText(button.text, button.x + button.w / 2, button.y + button.h / 1.7 + 8);
            ctx.fillStyle = "rgb(220, 220, 220)";
            ctx.font = "35px VT323";
            ctx.fillText(button.text, button.x + button.w / 2, button.y + button.h / 2 + 10);
        }
    };

    var initEverything;
    //General buttons
    {
        addButton(width / 2 - 280, height / 2 - 45, width / 2.5, 50, "Singleplayer", function() {
            screen = "creation menu";
        }, "main menu");
        addButton(width / 2 - 150, height / 2 + 100, width / 5, 40, "Create New World", function() {
            world = World();
            win.world = world;
            world.loadChunks();
            world.chunkGenQueue.sort(sortChunks);
            play();
        }, "creation menu");
        addButton(width / 2 - 150, height / 2 + 150, width / 5, 40, "Load Saved World", function() {
            if (loadString) {
                savebox.value = loadString;
            }
            savebox.hidden = false;
            screen = "loadsave menu";
        }, "creation menu");
        addButton(width / 2 - 280, height / 2 + 25, width / 2.5, 50, "Load Save", function() {
            world = World();
            win.world = world;
            if (savebox.value) {
                try {
                    world.loadSave(savebox.value);
                } catch(e) {
                    alert("Something went wrong!");
                    return;
                }
            }
            world.loadChunks();
            world.chunkGenQueue.sort(sortChunks);
            play();
        }, "loadsave menu");
        addButton(width / 2 - 180, height / 2 - 100, width / 4, 40, "World Type: Normal", function() {
            superflat = !superflat;
            if (superflat) {
                this.text = "World type: Superflat";
            } else {
                this.text = "World type: Normal";
            }
        }, "creation menu");
        addButton(width / 2 - 180, height / 2 - 50, width / 4, 40, "Game Mode: Creative", function(){
            // change gamemode
            screen = "comingsoon menu";
        }, "creation menu");
        addButton(width / 2 - 180, height / 2, width / 4, 40, "Difficulty: Peaceful", function() {
            // change difficulty
            screen = "comingsoon menu";
        }, "creation menu");
        addButton(width / 2 - 150, height / 2 + 200, width / 5, 40, "Cancel", function() {
            screen = "main menu";
        }, "creation menu");
        addButton(width / 2 - 280, height / 2 + 25, width / 2.5, 50, "Multiplayer", function() {
            screen = "rickrolled menu"
        }, "main menu");
        addButton(width / 2 - 280, height / 2 + 95, width / 2.5, 50, "Options", function() {
            screen = "options menu";
        }, "main menu");
        addButton(width / 2 - 220, 225, width / 3, 50, "Resume", function() {
            play();
        }, "pause");
        addButton(width / 2 - 220, 295, width / 3, 50, "Options", function() {
            screen = "pause options";
        }, "pause");
        addButton(width / 2 - 220, 365, width / 3, 50, "Get Save Code", function() {
            if (savebox.hidden) {
                savebox.hidden = false;
                saveDirections.hidden = false;
                savebox.value = world.getSaveString();
            } else {
                savebox.hidden = true;
                saveDirections.hidden = true;
            }
        }, "pause");
        addButton(width / 2 - 220, 435, width / 3, 50, "Exit Without Saving", function() {
            savebox.hidden = true;
            saveDirections.hidden = true;
            message.hidden = true;
            savebox.value = world.getSaveString();
            screen = "main menu";
        }, "pause");
        addButton(width / 2 - 220, 455, width / 3, 50, "Back", function() {
            screen = "main menu";
        }, "options menu");
        addButton(width / 2 - 220, 455, width / 3, 50, "Back", function() {
            screen = "pause";
        }, "pause options");
        addButton(width / 2 - 220, 395, width / 3, 50, "Back", function() {
            screen = "creation menu";
        }, "comingsoon menu");
        addButton(width / 2 - 220, 395, width / 3, 50, "\\_()_/", function() {
            screen = "main menu";
        }, "rickrolled menu");


        let settingsState = true;
        let mouseSense = 100;

        // Menu Settings
        addButton(width / 2 - 220, 155, width / 3, 50, "State: Increase", function() {
            settingsState = !settingsState;
            this.text = "State: " + (settingsState ? "Increase" : "Decrease");
        }, "options menu");
        addButton(width / 2 - 220, 245, width / 3, 50, "Render Distance: " + renderDistance + " chunks", function() {
            if(settingsState) {
                renderDistance++;
            } else if (renderDistance > 1) {
                renderDistance--;
            }
            this.text = "Render Distance: " + renderDistance + " chunks";
        }, "options menu");
        addButton(width / 2 - 220, 305, width / 3, 50, "FOV: " + fov, function() {
            if(settingsState && fov < 110) {
                fov += 5;
            } else if (!settingsState && fov > 30) {
                fov -= 5;
            }
            FOV(fov);
            this.text = "FOV: " + fov
        }, "options menu");
        addButton(width / 2 - 220, 365, width / 3, 50, "Mouse Sensitivity: " + mouseSense, function() {
            if(settingsState) {
                mouseSense += 10;
            } else if (mouseSense > 30) {
                mouseSense -= 10;
            }
            mouseS = 30000 / mouseSense;
            this.text = "Mouse Sensitivity: " + mouseSense;
        }, "options menu");

        // In-Game Settings
        addButton(width / 2 - 220, 155, width / 3, 50, "State: Increase", function() {
            settingsState = !settingsState;
            this.text = "State: " + (settingsState ? "Increase" : "Decrease");
        }, "pause options");
        addButton(width / 2 - 220, 245, width / 3, 50, "Render Distance: " + renderDistance + " chunks", function() {
            if(settingsState) {
                renderDistance++;
            } else if (renderDistance > 1) {
                renderDistance--;
            }
            this.text = "Render Distance: " + renderDistance + " chunks";
        }, "pause options");
        addButton(width / 2 - 220, 305, width / 3, 50, "FOV: " + fov, function() {
            if(settingsState && fov < 110) {
                fov += 5;
            } else if (!settingsState && fov > 30) {
                fov -= 5;
            }
            FOV(fov);
            this.text = "FOV: " + fov
            world.render();
        }, "pause options");
        addButton(width / 2 - 220, 365, width / 3, 50, "Mouse Sensitivity: " + mouseSense, function() {
            if(settingsState) {
                mouseSense += 10;
            } else if (mouseSense > 30) {
                mouseSense -= 10;
            }
            mouseS = 30000 / mouseSense;
            this.text = "Mouse Sensitivity: " + mouseSense;
        }, "pause options");
    }

    function initTextures() {
        let textureSize = 256;
        let texturePixels = newUint8Array(textureSize * textureSize * 4);
        textureMap = {};
        textureCoords = [];

        setPixel = function(textureNum, x, y, r, g, b, a) {
            let texX = textureNum & 15;
            let texY = textureNum >> 4;
            let offset = (texY * 16 + y) * 1024 + texX * 64 + x * 4;
            texturePixels[offset] = r;
            texturePixels[offset + 1] = g;
            texturePixels[offset + 2] = b;
            texturePixels[offset + 3] = a !== undefined ? a : 255;
        };
        getPixels = function(str) {
            // var w = parseInt(str.substr(0, 2), 36);
            // var h = parseInt(str.substr(2, 2), 36);
            var colors = [];
            var pixels = [];
            var dCount = 0;
            for (;str[4+dCount]==="0";dCount++) {}
            var ccount = parseInt(str.substr(4+dCount, dCount+1), 36);
            for (var i = 0; i < ccount; i++) {
                var num = parseInt(str.substr(5 + 2*dCount + i * 7, 7), 36);
                colors.push([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, num & 255 ]);
            }
            for (let i = 5 + 2*dCount + ccount * 7; i < str.length; i++) {
                let num = parseInt(str[i], 36);
                pixels.push(colors[num][0], colors[num][1], colors[num][2], colors[num][3]);
            }
            return pixels;
        };


        (function() {
        //Specify the texture coords for each index
            for (let i = 0; i < 256; i++) {
                let texX = i & 15;
                let texY = i >> 4;
                let offsetX = texX * 0.0625;
                let offsetY = texY * 0.0625;
                textureCoords.push(newFloat32Array([ 0.0625 + offsetX, offsetY, offsetX, offsetY, offsetX, 0.0625 + offsetY, 0.0625 + offsetX, 0.0625 + offsetY ]));
            }

            //Set all of the textures into 1 big tiled texture
            let n = 0;
            for (let i in textures) {
                if (typeof textures[i] === "function") {
                    textures[i](n);
                } else if (typeof textures[i] === "string") {
                    let pix = getPixels(textures[i]);
                    for (let j = 0; j < pix.length; j += 4) {
                        setPixel(n, j >> 2 & 15, j >> 6, pix[j], pix[j+1], pix[j+2], pix[j+3]);
                    }
                }
                textureMap[i] = n;
                n++;
            }

            //Set the hitbox texture to 1 pixel
            let arr = newFloat32Array(192)
            for (let i = 0; i < 192; i += 2) {
                arr[i] = textureCoords[textureMap.hitbox][2] + 0.01;
                arr[i + 1] = textureCoords[textureMap.hitbox][1] + 0.01;
            }
            textureCoords[textureMap.hitbox] = arr;
        })();

        tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.activeTexture(gl.TEXTURE0);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.uniform1i(glCache.locations.uSampler, 0);

        genIcons();
    }
    function drawIcon(x, y, id) {
        if (blockMode === SLAB) {
            id |= 128;
        }
        x =  x / (3 * height) - 0.1666 * width / height;
        y = y / (3 * height) - 0.1666;
        initModelView(x, y, 0, 0, 0);

        let buffer = blockIcons[id];
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(glCache.locations.aVertex, 3, gl.FLOAT, false, 24, 0);
        gl.vertexAttribPointer(glCache.locations.aTexture, 2, gl.FLOAT, false, 24, 12);
        gl.vertexAttribPointer(glCache.locations.aShadow, 1, gl.FLOAT, false, 24, 20);
        gl.drawElements(gl.TRIANGLES, 6 * 3, gl.UNSIGNED_INT, 0);
    }

    function hotbar() {
        let before = currentFov;
        FOV(90);

        for(let i = 0; i < inventory.hotbar.length; i ++) {
            if(inventory.hotbar[i]) {
                let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25;
                let y = height - inventory.size;
                drawIcon(x, y, inventory.hotbar[i]);
            }
        }

        FOV(before);
    }
    function hud() {
        let s = inventory.size;
        let x = width / 2 + 0.5;
        let y = height / 2 + 0.5;

        // Crosshair
        if (!p.spectator) {
            ctx.lineWidth = 1;
            ctx.strokeStyle = "white";
            ctx.beginPath();
            ctx.moveTo(x - 10, y);
            ctx.lineTo(x + 10, y);
            ctx.moveTo(x, y - 10);
            ctx.lineTo(x, y + 10);
            ctx.stroke();
        }

        //Hotbar
        x = width / 2 - 9 / 2 * s + 0.5 + 25;
        y = height - s * 1.5 + 0.5;

        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + s * 9, y);
        ctx.moveTo(x, y + s);
        ctx.lineTo(x + s * 9, y + s);
        for(let i = 0; i <= 9; i++) {
            ctx.moveTo(x + i * s, y);
            ctx.lineTo(x + i * s, y + s);
        }
        ctx.stroke();

        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.beginPath();

        ctx.strokeRect(width / 2 - 9 / 2 * s + inventory.hotbarSlot * s + 25, height - s * 1.5, s, s);

        let str = "Average Frame Time: " + analytics.displayedFrameTime + "ms\n"
        + "Worst Frame Time: " + analytics.displayedwFrameTime + "ms\n"
        + "Render Time: " + analytics.displayedRenderTime + "ms\n"
        + "Tick Time: " + analytics.displayedTickTime + "ms\n"
        + "Rendered Chunks: " + renderedChunks.toLocaleString() + " / " + world.loaded.length + "\n"
        + "Generated Chunks: " + generatedChunks.toLocaleString() + "\n"
        + "FPS: " + analytics.fps;

        if (p.autoBreak) {
            fastText("Super breaker enabled", 5, height - 89, 12);
        }

        ctx.textAlign = 'right';
        fastText(p2.x + ", " + p2.y + ", " + p2.z, width - 10, 15, 0);
        ctx.textAlign = 'left';
        fastText(str, 5, height - 77, 12);
    }
    function drawInv() {
        let x = 0;
        let y = 0;
        let s = inventory.size;
        let s2 = s / 2;
        let before = currentFov;
        let perRow = 13;

        //I don't know why, but this is barely transparent, so the gray bleeds through
        gl.clearColor(0.5, 0.5, 0.5, 0.0);
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
        ctx.fillStyle = "rgb(127, 127, 127)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        FOV(90);

        // Draw the grid
        ctx.lineWidth = 1;
        ctx.strokeStyle = "black";
        ctx.beginPath();
        for (y = 0; y < 10; y++) {
            ctx.moveTo(50.5 - s2, 50.5 - s2 + y * s);
            ctx.lineTo(50.5 - s2 + s * perRow, 50.5 - s2 + y * s);
        }
        y--;
        for (x = 0; x < perRow + 1; x++) {
            ctx.moveTo(50.5 - s2 + s * x, 50.5 - s2);
            ctx.lineTo(50.5 - s2 + s * x, 50.5 - s2 + y * s);
        }

        // Hotbar
        x = width / 2 - inventory.hotbar.length / 2 * s + 0.5 + 25;
        y = height - s * 1.5 + 0.5;
        ctx.moveTo(x, y);
        ctx.lineTo(x + s * 9, y);
        ctx.moveTo(x, y + s);
        ctx.lineTo(x + s * 9, y + s);
        for(let i = 0; i <= inventory.hotbar.length; i ++) {
            ctx.moveTo(x + i * s, y);
            ctx.lineTo(x + i * s, y + s);
        }
        ctx.stroke();

        let overHot = (mouseX - x) / s | 0;
        if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
            x += s * overHot;
            ctx.lineWidth = 2;
            ctx.strokeStyle = "white";
            ctx.beginPath();
            ctx.strokeRect(x, y, s, s);
        }

        //Box highlight in inv
        let overInv = Math.round((mouseY - 50) / s) * perRow + Math.round((mouseX - 50) / s);
        if (overInv >= 0 && overInv < blockData.length - 1 && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
            x = overInv % perRow * s + 50 - s2;
            y = (overInv / perRow | 0) * s + 50 - s2;
            ctx.lineWidth = 2;
            ctx.strokeStyle = "white";
            ctx.beginPath();
            ctx.strokeRect(x, y, s, s);
        }

        if (inventory.holding) {
            drawIcon(mouseX, mouseY, inventory.holding);
        }
        for (let i = 1; i < blockData.length; i++) {
            x = (i - 1) % perRow * s + 50;
            y = ((i - 1) / perRow | 0) * s + 50;
            drawIcon(x, y, i);
        }

        hotbar();
        //hud();
        ctx.drawImage(gl.canvas, 0, 0);

        FOV(before);
    }
    function clickInv() {
        let s = inventory.size;
        let s2 = s / 2;
        let perRow = 13;
        let over = Math.round((mouseY - 50) / s) * perRow + Math.round((mouseX - 50) / s);
        let x = width / 2 - 9 / 2 * s + 25;
        let y = height - s * 1.5;
        let overHot = (mouseX - x) / s | 0;
        if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
            let temp = inventory.hotbar[overHot];
            inventory.hotbar[overHot] = inventory.holding;
            inventory.holding = temp;
        } else if (over >= 0 && over < blockData.length - 1 && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
            inventory.holding = over + 1;
        } else {
            inventory.holding = 0;
        }
    }

    let unpauseDelay = 0;
    function mmoved(e) {
        p.rx -= e.movementY / mouseS;
        p.ry += e.movementX / mouseS;

        while(p.ry > Math.PI*2) {
            p.ry -= Math.PI*2;
        }
        while(p.ry < 0) {
            p.ry += Math.PI*2;
        }
        if(p.rx > Math.PI / 2) {
            p.rx = Math.PI / 2;
        }
        if(p.rx < -Math.PI / 2) {
            p.rx = -Math.PI / 2;
        }
    }
    function trackMouse(e) {
        mouseX = e.x;
        mouseY = e.y;
    }
    document.onmousemove = trackMouse;
    document.onpointerlockchange = function() {
        if (doc.pointerLockElement === canvas) {
            doc.onmousemove = mmoved;
        } else {
            doc.onmousemove = trackMouse;
            if (screen === "play" && !freezeFrame) {
                screen = "pause";
                message.hidden = false;
                unpauseDelay = Date.now() + 1000;
            }
        }
        for (let key in Key) {
            Key[key] = false;
        }
    };
    canvas.onmousedown = function(e) {
        mouseX = e.x;
        mouseY = e.y;
        switch(e.button) {
            case 0:
                Key.leftMouse = true;
                break;
            case 1:
                Key.middleMouse = true;
                updateHUD = true;
                inventory.hotbar[inventory.hotbarSlot] = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]);
                break;
            case 2:
                Key.rightMouse = true;
                break;
        }
        if(screen === "play") {
            if (doc.pointerLockElement !== canvas) {
                getPointer();
                p.lastBreak = Date.now();
            } else {
                place = false;
                if(e.button === 0) {
                    if(Key.control) {
                        place = true;
                    } else {
                        changeWorldBlock(0);
                    }
                }
                holding = inventory.hotbar[inventory.hotbarSlot];
                if(e.button === 2 && holding) {
                    place = true;
                }
                if(place) {
                    newWorldBlock();
                }
            }
        } else if (screen === "inventory") {
            clickInv();
        }

        let currentScreen = screen;
        for (let i = 0; i < buttons.length; i++) {
            if (buttons[i].screen === currentScreen) {
                clickButton(buttons[i]);
            }
        }
    };
    canvas.onmouseup = function(e) {
        switch(e.button) {
            case 0:
                Key.leftMouse = false;
                break;
            case 1:
                Key.middleMouse = false;
                break;
            case 2:
                Key.rightMouse = false;
                break;
        }
    };
    document.onkeydown = function(e) {
        if (e.repeat || Key[e.key.toLowerCase()]) {
            return;
        }
        let k = e.key.toLowerCase();
        Key[k] = true;
        if (k === "delete") {
            initEverything();
            releasePointer();
        }

        if (k === "t") {
            initTextures();
        }

        if (k === "enter") {
            blockMode ^= 1;
            updateHUD = true;
        }

        if (screen === "play") {
            if(k === "p") {
                releasePointer();
                screen = "pause";
                message.hidden = false;
            }

            if(k === "b") {
                p.autoBreak = !p.autoBreak;
                updateHUD = true;
            }

            if (k === " " && !p.spectator) {
                if (Date.now() < p.lastJump + 400) {
                    p.flying ^= true;
                } else {
                    p.lastJump = Date.now();
                }
            }

            if (k === "z") {
                FOV(10);
            }

            if (k === "shift" && !p.flying) {
                p.sneaking = true;
                p.sprinting = false;
                p.speed = 0.03;
                p.bottomH = 1.32;
            }

            if (k === "l") {
                p.spectator = !p.spectator;
                p.flying = true;
                p.onGround = false;
                updateHUD = true;
            }

            if (k === "e") {
                screen = "inventory";
                releasePointer();
            }

            if (k === ";") {
                releasePointer();
                freezeFrame = true;
            }

            if(Number(k)) {
                inventory.hotbarSlot = Number(k) - 1;
                holding = inventory.hotbar[inventory.hotbarSlot];
                updateHUD = true;
            }
        } else if (screen === "pause") {
            if(k === "p") {
                play();
            }
        } else if (screen === "inventory") {
            if (k === "e") {
                play();
            }
        }

    };
    document.onkeyup = function(e) {
        let k = e.key.toLowerCase();
        Key[k] = false;
        if(k === "escape" && (screen.includes("pause") || screen === "inventory") && Date.now() > unpauseDelay) {
            play();
        }
        if (screen === "play") {
            if (k === "z") {
                FOV(fov);
            }

            if (k === "shift" && p.sneaking) {
                p.sneaking = false;
                p.speed = 0.075;
                p.bottomH = 1.62;
                // p.y += 0.3;
            }
        }
    };
    canvas.onblur = function() {
        for (let key in Key) {
            Key[key] = false;

        }
    }
    canvas.oncontextmenu = function(e) {
        e.preventDefault();
    }

    function initEverything() {
        console.log("Initializing world.");

        worldSeed = Math.random() * 2000000000 | 0;

        seedHash(worldSeed);
        caveNoise = openSimplexNoise(worldSeed);
        noiseSeed(worldSeed);

        generatedChunks = 0;

        screen = "main menu";
        p = {
            speed: 0.075,
            velocity: new PVector(0, 0, 0),
            direction: new PVector(0, 0, 0),
            sprintSpeed: 1.5,
            flySpeed: 2.5,
            x: 8,
            y: superflat ? 6 : (Math.round(noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra),
            z: 8,
            previousX: 8,
            previousY: 70,
            previousZ: 8,
            w: 3 / 8,
            bottomH: 1.62,
            topH: 0.18,
            rx: Math.random() / 2,
            ry: random(7),
            onGround: false,
            jumpSpeed: 0.3,
            sprinting: false,
            maxYVelocity: 1.5,
            gravityStength: -0.032,
            lastUpdate: win.performance.now(),
            lastBreak: Date.now(),
            lastPlace: Date.now(),
            lastJump: Date.now(),
            autoBreak: false,
            flying: false,
            sneaking: false,
            spectator: false,
            frustum: [],
        };
        for (let i = 0; i < 4; i++) {
            p.frustum[i] = new Plane();
        }
        
        win.player = p;
        win.p2 = p2;

        if (!win.gl) {
            let canv = document.createElement('canvas');
            canv.width = ctx.canvas.width;
            canv.height = ctx.canvas.height;
            canv.style.position = "absolute";
            canv.style.zIndex = -1;
            canv.style.top = "0px";
            canv.style.left = "0px";
            // var ctxNames = ['experimental-webgl', 'webgl', 'webkit-3d'];
            // for (var i=0, l=ctxNames.length; i<l; i++) {
            //     gl = canv.getContext(ctxNames[i], {antialias: false});
            //     if (gl) {
            //         break;
            //     }
            // }
            gl = canv.getContext("webgl", { preserveDrawingBuffer: true, antialias: false, premultipliedAlpha: false });
            let ext = gl.getExtension('OES_element_index_uint');
            if (!ext) {
                alert("Please use a supported browser, or update your current browser.")
            }
            gl.viewport(0, 0, canv.width, canv.height);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            win.gl = gl;
        } else {
            gl = win.gl;
        }

        if (!document.body.contains(gl.canvas)) {
            document.body.append(gl.canvas);
        }

        if (win.location.origin === "https://www.kasandbox.org" && (loadString || GirlCraft.toString().length !== 149456)) {
            // Prevent Ctrl F
            message.innerHTML = '.oot lanigiro eht tuo kcehc ot>rb<erus eb ,siht ekil uoy fI>rb<.dralliW yb >a/<nahKeniM>"wen_"=tegrat "8676731005517465/cm/sc/gro.ymedacanahk.www//:sptth"=ferh a< fo>rb<ffo-nips a si margorp sihT'.split("").reverse().join("");
        }

        modelView = newFloat32Array(16);
        glCache = { attributes: {}, locations: {} };
        programObject3D = createProgramObject(gl, vertexShaderSrc3D, fragmentShaderSrc3D);
        gl.useProgram(programObject3D);
        glCache.locations.uEdge = gl.getUniformLocation(programObject3D, "uEdge");
        glCache.locations.uSampler = gl.getUniformLocation(programObject3D, "uSampler");
        glCache.locations.aShadow = gl.getAttribLocation(programObject3D, "aShadow");

        //Send the block textures to the GPU
        initTextures();
        initShapes();

        sideEdgeBuffers = {};
        for (let side in shapes.cube.verts) {
            let edgeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, newFloat32Array(shapes.cube.verts[side][0]), gl.STATIC_DRAW);
            sideEdgeBuffers[side] = edgeBuffer;
        }
        texCoordsBuffers = [];
        for (let t in textureCoords) {
            let buff = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buff);
            gl.bufferData(gl.ARRAY_BUFFER, textureCoords[t], gl.STATIC_DRAW);
            texCoordsBuffers.push(buff);
        }

        //Bind the Vertex Array Object (VAO) that will be used to draw everything
        indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexOrder, gl.STATIC_DRAW);

        //Tell it not to render the insides of blocks
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);

        gl.disableVertexAttribArray(glCache.locations.aShadow);
        gl.vertexAttrib1f(glCache.locations.aShadow, 1.0);
        gl.lineWidth(2);
        blockOutlines = false;
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(1, 1);
        gl.clearColor(84 / 255, 138 / 255, 184 / 255, 1.0);
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

        FOV(60);
        let HALF_PI = Math.PI / 2;
        initModelView(0, 0, 0, -HALF_PI / 6, -HALF_PI / 2.5);

        block2(1, -1, 5, 1);
        block2(2, -1, 5, 1);
        block2(3, -2, 4, 1);
        block2(3, -2, 5, 1);
        block2(2, -2, 4, 1);
        block2(1, -2, 4, 1);
        block2(0, -3, 4, 1);
        block2(1, -3, 4, 2);
        block2(1, -4, 3, 1);
        block2(2, -3, 3, 1);
        block2(3, -2, 3, 1);
        block2(3, -3, 2, 1);
        block2(5, -3, 2, 1);
        block2(4, -4, 1, 1);
        block2(4, -3, 2, 1);
        block2(0, -2, 5, 1);
        block2(4, -2, 3, 1);
        block2(4, -2, 4, 1);
        block2(5, -3, 3, 1);
        //ctx.drawImage(gl.canvas, 0, 0);
        FOV(fov);
    }

    let debugMenu = false;
    function gameLoop() {
        let frameStart = win.performance.now();
        if (!screen) {
            initEverything();
            releasePointer();
        }

        if(screen.includes("menu")) {
            let title = "yxnvCraft";
            let subtext = "Y O M A M A E D I T I O N"
            cursor(ARROW);
            strokeWeight(1);
            ctx.clearRect(0, 0, width, height);
            ctx.textAlign = 'center';

            ctx.font = "bold 150px VT323";
            fill(30);
            text(title, width / 2, 158);
            fill(40);
            text(title, width / 2, 155);
            ctx.font = "bold 151px VT323";
            fill(50);
            text(title, width / 2, 152);
            fill(70);
            text(title, width / 2, 150);
            fill(90);
            ctx.font = "bold 152px VT323";
            text(title, width / 2, 148);
            fill(110);
            text(title, width / 2, 145);

            ctx.font = "bold 31.5px VT323";
            fill(30);
            text(subtext, width / 2, 200);
            fill(40);
            text(subtext, width / 2, 198.5);
            fill(50);
            text(subtext, width / 2, 197);
            ctx.font = "bold 31.65px VT323";
            fill(70);
            text(subtext, width / 2, 195.5);
            fill(90);
            text(subtext, width / 2, 194);
            fill(110);
            text(subtext, width / 2, 192.5);

            if(screen === "main menu") {
                fill(220);
                ctx.font = "20px VT323";
                ctx.textAlign = 'left';
                text("GirlCraft " + version, width - (width - 2), height - 2);
            } else if(screen === "creation menu") {
                // Buttons will draw themselves
            } else if(screen === "loadsave menu") {
                // Buttons will do the work
            } else if(screen === "options menu") {
                // Still nothing to do
            } else if(screen === "rickrolled menu") {
                ctx.beginPath();
                ctx.fillStyle = "white";
                ctx.rect(0, 0, width, height);
                ctx.font = "40px VT323";
                ctx.textAlign = 'center';
                fill(0);
                text("Multiplayer is impossible on REPL.", width / 2, 300);
                ctx.beginPath();
            } else if(screen === "comingsoon menu") {
                ctx.beginPath();
                ctx.fillStyle = "white";
                ctx.rect(0, 0, width, height);
                ctx.font = "100px VT323";
                ctx.textAlign = 'center';
                fill(0);
                text("COMING SOON", width / 2, 325);
                ctx.beginPath();
            }
        } else if(screen === "play") {
            controls();
            runGravity();
            resolveContactsAndUpdatePosition();

            if (updateHUD) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                gl.clearColor(0.0, 0.0, 0.0, 0.0);
                gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
                hotbar();
                hud();
                ctx.drawImage(gl.canvas, 0, 0);
                updateHUD = false;
                freezeFrame = false;

                gl.clearColor(84 / 255, 138 / 255, 184 / 255, 1.0);
            }
            defineWorld(); // Load, draw, and update the world
            // gl.flush();
            // gl.finish();
        } else if (screen === "inventory") {
            drawInv();
        } else if(screen.includes("pause")) {
            cursor(ARROW);
            strokeWeight(1);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(gl.canvas, 0, 0);

            // ctx.globalAlpha = 0.5;
            // ctx.rect(-2, -2, width + 2, height + 2);
            // ctx.globalAlpha = 1;

            textSize(60);
            fill(0, 0, 0);
            ctx.textAlign = 'center';
            text("Paused", width / 2, 60);
            if(screen === "pause options") {
                ctx.beginPath();
                ctx.beginPath();
            }
        }
        buttons.forEach(drawButton);

        if (Date.now() - analytics.lastUpdate > 500 && analytics.frames) {
            analytics.displayedTickTime = (analytics.totalTickTime / analytics.frames).toFixed(1);
            analytics.displayedRenderTime = (analytics.totalRenderTime / analytics.frames).toFixed(1);
            analytics.displayedFrameTime = (analytics.totalFrameTime / analytics.frames).toFixed(1);
            analytics.fps = Math.round(analytics.frames * 1000 / (Date.now() - analytics.lastUpdate));
            analytics.displayedwFrameTime = analytics.worstFrameTime.toFixed(1);
            analytics.frames = 0;
            analytics.totalRenderTime = 0;
            analytics.totalTickTime = 0;
            analytics.totalFrameTime = 0;
            analytics.worstFrameTime = 0;
            analytics.lastUpdate = Date.now();
            updateHUD = true;
        }

        analytics.frames++;
        analytics.totalFrameTime += win.performance.now() - frameStart;
        analytics.worstFrameTime = Math.max(win.performance.now() - frameStart, analytics.worstFrameTime);
        win.raf = requestAnimationFrame(gameLoop);
    }
    return gameLoop;
}
console.log(GirlCraft.toString().length)
init = GirlCraft();
if (window.parent.raf) {
    window.cancelAnimationFrame(window.parent.raf);
    console.log("Canceled", window.parent.raf)
}
init();


    </script>
    </body>
</html>
